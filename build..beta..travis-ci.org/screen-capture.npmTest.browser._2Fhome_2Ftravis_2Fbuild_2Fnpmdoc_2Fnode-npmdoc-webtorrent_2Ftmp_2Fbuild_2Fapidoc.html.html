<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://webtorrent.io">webtorrent (v0.98.15)</a>
</h1>
<h4>Streaming torrent client</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent">module webtorrent</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">webtorrent.</span>WEBRTC_SUPPORT</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file">
            function <span class="apidocSignatureSpan">webtorrent.</span>file
            <span class="apidocSignatureSpan">(torrent, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file_stream">
            function <span class="apidocSignatureSpan">webtorrent.</span>file_stream
            <span class="apidocSignatureSpan">(file, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.rarity_map">
            function <span class="apidocSignatureSpan">webtorrent.</span>rarity_map
            <span class="apidocSignatureSpan">(torrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.super_">
            function <span class="apidocSignatureSpan">webtorrent.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.tcp_pool">
            function <span class="apidocSignatureSpan">webtorrent.</span>tcp_pool
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent">
            function <span class="apidocSignatureSpan">webtorrent.</span>torrent
            <span class="apidocSignatureSpan">(torrentId, client, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.webconn">
            function <span class="apidocSignatureSpan">webtorrent.</span>webconn
            <span class="apidocSignatureSpan">(url, torrent)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webtorrent.</span>file.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webtorrent.</span>file_stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webtorrent.</span>peer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webtorrent.</span>rarity_map.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webtorrent.</span>tcp_pool.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webtorrent.</span>torrent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">webtorrent.</span>webconn.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.file">module webtorrent.file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.file">
            function <span class="apidocSignatureSpan">webtorrent.</span>file
            <span class="apidocSignatureSpan">(torrent, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.super_">
            function <span class="apidocSignatureSpan">webtorrent.file.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.file.prototype">module webtorrent.file.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype._destroy">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>_destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype._getMimeType">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>_getMimeType
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.appendTo">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>appendTo
            <span class="apidocSignatureSpan">(elem, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.createReadStream">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>createReadStream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.deselect">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>deselect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.getBlob">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>getBlob
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.getBlobURL">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>getBlobURL
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.getBuffer">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>getBuffer
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.renderTo">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>renderTo
            <span class="apidocSignatureSpan">(elem, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file.prototype.select">
            function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>select
            <span class="apidocSignatureSpan">(priority)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.file_stream">module webtorrent.file_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file_stream.file_stream">
            function <span class="apidocSignatureSpan">webtorrent.</span>file_stream
            <span class="apidocSignatureSpan">(file, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file_stream.super_">
            function <span class="apidocSignatureSpan">webtorrent.file_stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.file_stream.prototype">module webtorrent.file_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file_stream.prototype._destroy">
            function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>_destroy
            <span class="apidocSignatureSpan">(err, onclose)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file_stream.prototype._notify">
            function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>_notify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file_stream.prototype._read">
            function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.file_stream.prototype.destroy">
            function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>destroy
            <span class="apidocSignatureSpan">(onclose)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.peer">module webtorrent.peer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.peer.createTCPIncomingPeer">
            function <span class="apidocSignatureSpan">webtorrent.peer.</span>createTCPIncomingPeer
            <span class="apidocSignatureSpan">(conn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.peer.createTCPOutgoingPeer">
            function <span class="apidocSignatureSpan">webtorrent.peer.</span>createTCPOutgoingPeer
            <span class="apidocSignatureSpan">(addr, swarm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.peer.createWebRTCPeer">
            function <span class="apidocSignatureSpan">webtorrent.peer.</span>createWebRTCPeer
            <span class="apidocSignatureSpan">(conn, swarm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.peer.createWebSeedPeer">
            function <span class="apidocSignatureSpan">webtorrent.peer.</span>createWebSeedPeer
            <span class="apidocSignatureSpan">(url, swarm)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.rarity_map">module webtorrent.rarity_map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.rarity_map.rarity_map">
            function <span class="apidocSignatureSpan">webtorrent.</span>rarity_map
            <span class="apidocSignatureSpan">(torrent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.rarity_map.prototype">module webtorrent.rarity_map.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.rarity_map.prototype._cleanupWireEvents">
            function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>_cleanupWireEvents
            <span class="apidocSignatureSpan">(wire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.rarity_map.prototype._initWire">
            function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>_initWire
            <span class="apidocSignatureSpan">(wire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.rarity_map.prototype.destroy">
            function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.rarity_map.prototype.getRarestPiece">
            function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>getRarestPiece
            <span class="apidocSignatureSpan">(pieceFilterFunc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.rarity_map.prototype.recalculate">
            function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>recalculate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.tcp_pool">module webtorrent.tcp_pool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.tcp_pool.tcp_pool">
            function <span class="apidocSignatureSpan">webtorrent.</span>tcp_pool
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.tcp_pool.prototype">module webtorrent.tcp_pool.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.tcp_pool.prototype._onConnection">
            function <span class="apidocSignatureSpan">webtorrent.tcp_pool.prototype.</span>_onConnection
            <span class="apidocSignatureSpan">(conn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.tcp_pool.prototype.destroy">
            function <span class="apidocSignatureSpan">webtorrent.tcp_pool.prototype.</span>destroy
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.torrent">module webtorrent.torrent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.torrent">
            function <span class="apidocSignatureSpan">webtorrent.</span>torrent
            <span class="apidocSignatureSpan">(torrentId, client, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.super_">
            function <span class="apidocSignatureSpan">webtorrent.torrent.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.torrent.prototype">module webtorrent.torrent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._addIncomingPeer">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_addIncomingPeer
            <span class="apidocSignatureSpan">(peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._addPeer">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_addPeer
            <span class="apidocSignatureSpan">(peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._checkDone">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_checkDone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._debug">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._destroy">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_destroy
            <span class="apidocSignatureSpan">(err, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._drain">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_drain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._gcSelections">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_gcSelections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._getMetadataFromServer">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_getMetadataFromServer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._hotswap">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_hotswap
            <span class="apidocSignatureSpan">(wire, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._markVerified">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_markVerified
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._onListening">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onListening
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._onMetadata">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onMetadata
            <span class="apidocSignatureSpan">(metadata)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._onParsedTorrent">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onParsedTorrent
            <span class="apidocSignatureSpan">(parsedTorrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._onStore">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onStore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._onTorrentId">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onTorrentId
            <span class="apidocSignatureSpan">(torrentId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._onWire">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onWire
            <span class="apidocSignatureSpan">(wire, addr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._onWireWithMetadata">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onWireWithMetadata
            <span class="apidocSignatureSpan">(wire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._processParsedTorrent">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_processParsedTorrent
            <span class="apidocSignatureSpan">(parsedTorrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._rechoke">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_rechoke
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._request">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_request
            <span class="apidocSignatureSpan">(wire, index, hotswap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._update">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_update
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._updateInterest">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_updateInterest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._updateSelections">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_updateSelections
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._updateWire">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_updateWire
            <span class="apidocSignatureSpan">(wire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._validAddr">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_validAddr
            <span class="apidocSignatureSpan">(addr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype._verifyPieces">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_verifyPieces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.addPeer">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>addPeer
            <span class="apidocSignatureSpan">(peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.addWebSeed">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>addWebSeed
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.createServer">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>createServer
            <span class="apidocSignatureSpan">(requestListener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.critical">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>critical
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.deselect">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>deselect
            <span class="apidocSignatureSpan">(start, end, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.destroy">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>destroy
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.getFileModtimes">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>getFileModtimes
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.load">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>load
            <span class="apidocSignatureSpan">(streams, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.pause">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.removePeer">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>removePeer
            <span class="apidocSignatureSpan">(peer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.resume">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.torrent.prototype.select">
            function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>select
            <span class="apidocSignatureSpan">(start, end, priority, notify)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.webconn">module webtorrent.webconn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.webconn.webconn">
            function <span class="apidocSignatureSpan">webtorrent.</span>webconn
            <span class="apidocSignatureSpan">(url, torrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.webconn.super_">
            function <span class="apidocSignatureSpan">webtorrent.webconn.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.webtorrent.webconn.prototype">module webtorrent.webconn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.webconn.prototype._init">
            function <span class="apidocSignatureSpan">webtorrent.webconn.prototype.</span>_init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.webconn.prototype.destroy">
            function <span class="apidocSignatureSpan">webtorrent.webconn.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.webtorrent.webconn.prototype.httpRequest">
            function <span class="apidocSignatureSpan">webtorrent.webconn.prototype.</span>httpRequest
            <span class="apidocSignatureSpan">(pieceIndex, offset, length, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent" id="apidoc.module.webtorrent">module webtorrent</a></h1>




    <h2>
        <a href="#apidoc.element.webtorrent.file" id="apidoc.element.webtorrent.file">
        function <span class="apidocSignatureSpan">webtorrent.</span>file
        <span class="apidocSignatureSpan">(torrent, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function File(torrent, file) {
  EventEmitter.call(this)

  this._torrent = torrent
  this._destroyed = false

  this.name = file.name
  this.path = file.path
  this.length = file.length
  this.offset = file.offset

  this.done = false

  var start = file.offset
  var end = start + file.length - 1

  this._startPiece = start / this._torrent.pieceLength | 0
  this._endPiece = end / this._torrent.pieceLength | 0

  if (this.length === 0) {
    this.done = true
    this.emit('done')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file_stream" id="apidoc.element.webtorrent.file_stream">
        function <span class="apidocSignatureSpan">webtorrent.</span>file_stream
        <span class="apidocSignatureSpan">(file, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileStream(file, opts) {
  stream.Readable.call(this, opts)

  this.destroyed = false
  this._torrent = file._torrent

  var start = (opts &amp;&amp; opts.start) || 0
  var end = (opts &amp;&amp; opts.end &amp;&amp; opts.end &lt; file.length)
    ? opts.end
    : file.length - 1

  var pieceLength = file._torrent.pieceLength

  this._startPiece = (start + file.offset) / pieceLength | 0
  this._endPiece = (end + file.offset) / pieceLength | 0

  this._piece = this._startPiece
  this._offset = (start + file.offset) - (this._startPiece * pieceLength)

  this._missing = end - start + 1
  this._reading = false
  this._notifying = false
  this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.rarity_map" id="apidoc.element.webtorrent.rarity_map">
        function <span class="apidocSignatureSpan">webtorrent.</span>rarity_map
        <span class="apidocSignatureSpan">(torrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RarityMap(torrent) {
  var self = this

  self._torrent = torrent
  self._numPieces = torrent.pieces.length
  self._pieces = []

  self._onWire = function (wire) {
    self.recalculate()
    self._initWire(wire)
  }
  self._onWireHave = function (index) {
    self._pieces[index] += 1
  }
  self._onWireBitfield = function () {
    self.recalculate()
  }

  self._torrent.wires.forEach(function (wire) {
    self._initWire(wire)
  })
  self._torrent.on('wire', self._onWire)
  self.recalculate()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.super_" id="apidoc.element.webtorrent.super_">
        function <span class="apidocSignatureSpan">webtorrent.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.tcp_pool" id="apidoc.element.webtorrent.tcp_pool">
        function <span class="apidocSignatureSpan">webtorrent.</span>tcp_pool
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TCPPool(client) {
  var self = this
  debug('create tcp pool (port %s)', client.torrentPort)

  self.server = net.createServer()
  self._client = client

  // Temporarily store incoming connections so they can be destroyed if the server is
  // closed before the connection is passed off to a Torrent.
  self._pendingConns = []

  self._onConnectionBound = function (conn) {
    self._onConnection(conn)
  }

  self._onListening = function () {
    self._client._onListening()
  }

  self._onError = function (err) {
    self._client._destroy(err)
  }

  self.server.on('connection', self._onConnectionBound)
  self.server.on('listening', self._onListening)
  self.server.on('error', self._onError)

  self.server.listen(client.torrentPort)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent" id="apidoc.element.webtorrent.torrent">
        function <span class="apidocSignatureSpan">webtorrent.</span>torrent
        <span class="apidocSignatureSpan">(torrentId, client, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Torrent(torrentId, client, opts) {
  EventEmitter.call(this)

  this._debugId = 'unknown infohash'
  this.client = client

  this.announce = opts.announce
  this.urlList = opts.urlList

  this.path = opts.path
  this._store = opts.store || FSChunkStore
  this._getAnnounceOpts = opts.getAnnounceOpts

  this.strategy = opts.strategy || 'sequential'

  this.maxWebConns = opts.maxWebConns || 4

  this._rechokeNumSlots = (opts.uploads === false || opts.uploads === 0)
    ? 0
    : (+opts.uploads || 10)
  this._rechokeOptimisticWire = null
  this._rechokeOptimisticTime = 0
  this._rechokeIntervalId = null

  this.ready = false
  this.destroyed = false
  this.paused = false
  this.done = false

  this.metadata = null
  this.store = null
  this.files = []
  this.pieces = []

  this._amInterested = false
  this._selections = []
  this._critical = []

  this.wires = [] // open wires (added *after* handshake)

  this._queue = [] // queue of outgoing tcp peers to connect to
  this._peers = {} // connected peers (addr/peerId -&gt; Peer)
  this._peersLength = 0 // number of elements in `this._peers` (cache, for perf)

  // stats
  this.received = 0
  this.uploaded = 0
  this._downloadSpeed = speedometer()
  this._uploadSpeed = speedometer()

  // for cleanup
  this._servers = []
  this._xsRequests = []

  // TODO: remove this and expose a hook instead
  // optimization: don't recheck every file if it hasn't changed
  this._fileModtimes = opts.fileModtimes

  if (torrentId !== null) this._onTorrentId(torrentId)

  this._debug('new torrent')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.webconn" id="apidoc.element.webtorrent.webconn">
        function <span class="apidocSignatureSpan">webtorrent.</span>webconn
        <span class="apidocSignatureSpan">(url, torrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebConn(url, torrent) {
  Wire.call(this)

  this.url = url
  this.webPeerId = sha1.sync(url)
  this._torrent = torrent

  this._init()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.file" id="apidoc.module.webtorrent.file">module webtorrent.file</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.file.file" id="apidoc.element.webtorrent.file.file">
        function <span class="apidocSignatureSpan">webtorrent.</span>file
        <span class="apidocSignatureSpan">(torrent, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function File(torrent, file) {
  EventEmitter.call(this)

  this._torrent = torrent
  this._destroyed = false

  this.name = file.name
  this.path = file.path
  this.length = file.length
  this.offset = file.offset

  this.done = false

  var start = file.offset
  var end = start + file.length - 1

  this._startPiece = start / this._torrent.pieceLength | 0
  this._endPiece = end / this._torrent.pieceLength | 0

  if (this.length === 0) {
    this.done = true
    this.emit('done')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.super_" id="apidoc.element.webtorrent.file.super_">
        function <span class="apidocSignatureSpan">webtorrent.file.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.file.prototype" id="apidoc.module.webtorrent.file.prototype">module webtorrent.file.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype._destroy" id="apidoc.element.webtorrent.file.prototype._destroy">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>_destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_destroy = function () {
  this._destroyed = true
  this._torrent = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self._uploadSpeed = speedometer()

  if (opts.dht !== false &amp;&amp; typeof DHT === 'function' /* browser exclude */) {
// use a single DHT instance for all torrents, so the routing table can be reused
self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))

self.dht.once('error', function (err) {
  self.<span class="apidocCodeKeywordSpan">_destroy</span>(err)
})

self.dht.once('listening', function () {
  var address = self.dht.address()
  if (address) self.dhtPort = address.port
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype._getMimeType" id="apidoc.element.webtorrent.file.prototype._getMimeType">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>_getMimeType
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getMimeType = function () {
  return render.mime[path.extname(this.name).toLowerCase()]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

File.prototype.getBuffer = function (cb) {
  streamToBuffer(this.createReadStream(), this.length, cb)
}

File.prototype.getBlob = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  streamToBlob(this.createReadStream(), this.<span class="apidocCodeKeywordSpan">_getMimeType</span>(), cb)
}

File.prototype.getBlobURL = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  streamToBlobURL(this.createReadStream(), this._getMimeType(), cb)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.appendTo" id="apidoc.element.webtorrent.file.prototype.appendTo">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>appendTo
        <span class="apidocSignatureSpan">(elem, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendTo = function (elem, opts, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.append(this, elem, opts, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
client.add(magnetURI, function (torrent) {
  // Got torrent metadata!
  console.log('Client is downloading:', torrent.infoHash)

  torrent.files.forEach(function (file) {
    // Display the file by appending it to the DOM. Supports video, audio, images, and
    // more. Specify a container element (CSS selector or reference to DOM node).
    file.<span class="apidocCodeKeywordSpan">appendTo</span>('body')
  })
})
```

##### Seeding a file is simple, too:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.createReadStream" id="apidoc.element.webtorrent.file.prototype.createReadStream">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>createReadStream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReadStream = function (opts) {
  var self = this
  if (this.length === 0) {
    var empty = new stream.PassThrough()
    process.nextTick(function () {
      empty.end()
    })
    return empty
  }

  var fileStream = new FileStream(self, opts)
  self._torrent.select(fileStream._startPiece, fileStream._endPiece, true, function () {
    fileStream._notify()
  })
  eos(fileStream, function () {
    if (self._destroyed) return
    if (!self._torrent.destroyed) {
      self._torrent.deselect(fileStream._startPiece, fileStream._endPiece, true)
    }
  })
  return fileStream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      self._torrent.deselect(fileStream._startPiece, fileStream._endPiece, true)
    }
  })
  return fileStream
}

File.prototype.getBuffer = function (cb) {
  streamToBuffer(this.<span class="apidocCodeKeywordSpan">createReadStream</span>(), this.length, cb)
}

File.prototype.getBlob = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  streamToBlob(this.createReadStream(), this._getMimeType(), cb)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.deselect" id="apidoc.element.webtorrent.file.prototype.deselect">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>deselect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deselect = function () {
  if (this.length === 0) return
  this._torrent.deselect(this._startPiece, this._endPiece, false)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

FileStream.prototype._destroy = function (err, onclose) {
  if (this.destroyed) return
  this.destroyed = true

  if (!this._torrent.destroyed) {
    this._torrent.<span class="apidocCodeKeywordSpan">deselect</span>(this._startPiece, this._endPiece, true)
  }

  if (err) this.emit('error', err)
  this.emit('close')
  if (onclose) onclose()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.getBlob" id="apidoc.element.webtorrent.file.prototype.getBlob">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>getBlob
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBlob = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  streamToBlob(this.createReadStream(), this._getMimeType(), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.getBlobURL" id="apidoc.element.webtorrent.file.prototype.getBlobURL">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>getBlobURL
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBlobURL = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  streamToBlobURL(this.createReadStream(), this._getMimeType(), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.getBuffer" id="apidoc.element.webtorrent.file.prototype.getBuffer">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>getBuffer
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBuffer = function (cb) {
  streamToBuffer(this.createReadStream(), this.length, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.renderTo" id="apidoc.element.webtorrent.file.prototype.renderTo">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>renderTo
        <span class="apidocSignatureSpan">(elem, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderTo = function (elem, opts, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.render(this, elem, opts, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file.prototype.select" id="apidoc.element.webtorrent.file.prototype.select">
        function <span class="apidocSignatureSpan">webtorrent.file.prototype.</span>select
        <span class="apidocSignatureSpan">(priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (priority) {
  if (this.length === 0) return
  this._torrent.select(this._startPiece, this._endPiece, priority)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return downloaded
  }
})

File.prototype.select = function (priority) {
  if (this.length === 0) return
  this._torrent.<span class="apidocCodeKeywordSpan">select</span>(this._startPiece, this._endPiece, priority)
}

File.prototype.deselect = function () {
  if (this.length === 0) return
  this._torrent.deselect(this._startPiece, this._endPiece, false)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.file_stream" id="apidoc.module.webtorrent.file_stream">module webtorrent.file_stream</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.file_stream.file_stream" id="apidoc.element.webtorrent.file_stream.file_stream">
        function <span class="apidocSignatureSpan">webtorrent.</span>file_stream
        <span class="apidocSignatureSpan">(file, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FileStream(file, opts) {
  stream.Readable.call(this, opts)

  this.destroyed = false
  this._torrent = file._torrent

  var start = (opts &amp;&amp; opts.start) || 0
  var end = (opts &amp;&amp; opts.end &amp;&amp; opts.end &lt; file.length)
    ? opts.end
    : file.length - 1

  var pieceLength = file._torrent.pieceLength

  this._startPiece = (start + file.offset) / pieceLength | 0
  this._endPiece = (end + file.offset) / pieceLength | 0

  this._piece = this._startPiece
  this._offset = (start + file.offset) - (this._startPiece * pieceLength)

  this._missing = end - start + 1
  this._reading = false
  this._notifying = false
  this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file_stream.super_" id="apidoc.element.webtorrent.file_stream.super_">
        function <span class="apidocSignatureSpan">webtorrent.file_stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &amp;&amp; typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.file_stream.prototype" id="apidoc.module.webtorrent.file_stream.prototype">module webtorrent.file_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.file_stream.prototype._destroy" id="apidoc.element.webtorrent.file_stream.prototype._destroy">
        function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>_destroy
        <span class="apidocSignatureSpan">(err, onclose)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_destroy = function (err, onclose) {
  if (this.destroyed) return
  this.destroyed = true

  if (!this._torrent.destroyed) {
    this._torrent.deselect(this._startPiece, this._endPiece, true)
  }

  if (err) this.emit('error', err)
  this.emit('close')
  if (onclose) onclose()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self._uploadSpeed = speedometer()

  if (opts.dht !== false &amp;&amp; typeof DHT === 'function' /* browser exclude */) {
// use a single DHT instance for all torrents, so the routing table can be reused
self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))

self.dht.once('error', function (err) {
  self.<span class="apidocCodeKeywordSpan">_destroy</span>(err)
})

self.dht.once('listening', function () {
  var address = self.dht.address()
  if (address) self.dhtPort = address.port
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file_stream.prototype._notify" id="apidoc.element.webtorrent.file_stream.prototype._notify">
        function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>_notify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_notify = function () {
  var self = this

  if (!self._reading || self._missing === 0) return
  if (!self._torrent.bitfield.get(self._piece)) {
    return self._torrent.critical(self._piece, self._piece + self._criticalLength)
  }

  if (self._notifying) return
  self._notifying = true

  var p = self._piece
  self._torrent.store.get(p, function (err, buffer) {
    self._notifying = false
    if (self.destroyed) return
    if (err) return self._destroy(err)
    debug('read %s (length %s) (err %s)', p, buffer.length, err &amp;&amp; err.message)

    if (self._offset) {
      buffer = buffer.slice(self._offset)
      self._offset = 0
    }

    if (self._missing &lt; buffer.length) {
      buffer = buffer.slice(0, self._missing)
    }
    self._missing -= buffer.length

    debug('pushing buffer of length %s', buffer.length)
    self._reading = false
    self.push(buffer)

    if (self._missing === 0) self.push(null)
  })
  self._piece += 1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._notifying = false
this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
}

FileStream.prototype._read = function () {
if (this._reading) return
this._reading = true
this.<span class="apidocCodeKeywordSpan">_notify</span>()
}

FileStream.prototype._notify = function () {
var self = this

if (!self._reading || self._missing === 0) return
if (!self._torrent.bitfield.get(self._piece)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file_stream.prototype._read" id="apidoc.element.webtorrent.file_stream.prototype._read">
        function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
  if (this._reading) return
  this._reading = true
  this._notify()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.file_stream.prototype.destroy" id="apidoc.element.webtorrent.file_stream.prototype.destroy">
        function <span class="apidocSignatureSpan">webtorrent.file_stream.prototype.</span>destroy
        <span class="apidocSignatureSpan">(onclose)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (onclose) {
  this._destroy(null, onclose)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
var torrent = this.get(torrentId)
if (!torrent) return
this.torrents.splice(this.torrents.indexOf(torrent), 1)
torrent.<span class="apidocCodeKeywordSpan">destroy</span>(cb)
}

WebTorrent.prototype.address = function () {
if (!this.listening) return null
return this._tcpPool
  ? this._tcpPool.server.address()
  : { address: '0.0.0.0', family: 'IPv4', port: 0 }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.peer" id="apidoc.module.webtorrent.peer">module webtorrent.peer</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.peer.createTCPIncomingPeer" id="apidoc.element.webtorrent.peer.createTCPIncomingPeer">
        function <span class="apidocSignatureSpan">webtorrent.peer.</span>createTCPIncomingPeer
        <span class="apidocSignatureSpan">(conn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTCPIncomingPeer = function (conn) {
  var addr = conn.remoteAddress + ':' + conn.remotePort
  var peer = new Peer(addr, 'tcpIncoming')
  peer.conn = conn
  peer.addr = addr

  peer.onConnect()

  return peer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  conn.destroy()
  return
}

self._pendingConns.push(conn)
conn.once('close', cleanupPending)

var peer = Peer.<span class="apidocCodeKeywordSpan">createTCPIncomingPeer</span>(conn)

var wire = peer.wire
wire.once('handshake', onHandshake)

function onHandshake (infoHash, peerId) {
  cleanupPending()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.peer.createTCPOutgoingPeer" id="apidoc.element.webtorrent.peer.createTCPOutgoingPeer">
        function <span class="apidocSignatureSpan">webtorrent.peer.</span>createTCPOutgoingPeer
        <span class="apidocSignatureSpan">(addr, swarm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTCPOutgoingPeer = function (addr, swarm) {
  var peer = new Peer(addr, 'tcpOutgoing')
  peer.addr = addr
  peer.swarm = swarm

  return peer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

self._debug('add peer %s', id)

var newPeer
if (typeof peer === 'string') {
  // `peer` is an addr ("ip:port" string)
  newPeer = Peer.<span class="apidocCodeKeywordSpan">createTCPOutgoingPeer</span>(peer, self)
} else {
  // `peer` is a WebRTC connection (simple-peer)
  newPeer = Peer.createWebRTCPeer(peer, self)
}

self._peers[newPeer.id] = newPeer
self._peersLength += 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.peer.createWebRTCPeer" id="apidoc.element.webtorrent.peer.createWebRTCPeer">
        function <span class="apidocSignatureSpan">webtorrent.peer.</span>createWebRTCPeer
        <span class="apidocSignatureSpan">(conn, swarm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWebRTCPeer = function (conn, swarm) {
  var peer = new Peer(conn.id, 'webrtc')
  peer.conn = conn
  peer.swarm = swarm

  if (peer.conn.connected) {
    peer.onConnect()
  } else {
    peer.conn.once('connect', function () { peer.onConnect() })
    peer.conn.once('error', function (err) { peer.destroy(err) })
    peer.startConnectTimeout()
  }

  return peer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var newPeer
if (typeof peer === 'string') {
  // `peer` is an addr ("ip:port" string)
  newPeer = Peer.createTCPOutgoingPeer(peer, self)
} else {
  // `peer` is a WebRTC connection (simple-peer)
  newPeer = Peer.<span class="apidocCodeKeywordSpan">createWebRTCPeer</span>(peer, self)
}

self._peers[newPeer.id] = newPeer
self._peersLength += 1

if (typeof peer === 'string') {
  // `peer` is an addr ("ip:port" string)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.peer.createWebSeedPeer" id="apidoc.element.webtorrent.peer.createWebSeedPeer">
        function <span class="apidocSignatureSpan">webtorrent.peer.</span>createWebSeedPeer
        <span class="apidocSignatureSpan">(url, swarm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createWebSeedPeer = function (url, swarm) {
  var peer = new Peer(url, 'webSeed')
  peer.swarm = swarm
  peer.conn = new WebConn(url, swarm)

  peer.onConnect()

  return peer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.emit('warning', new Error('ignoring duplicate web seed: ' + url))
    this.emit('invalidPeer', url)
    return
  }

  this._debug('add web seed %s', url)

  var newPeer = Peer.<span class="apidocCodeKeywordSpan">createWebSeedPeer</span>(url, this)
  this._peers[newPeer.id] = newPeer
  this._peersLength += 1

  this.emit('peer', url)
}

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.rarity_map" id="apidoc.module.webtorrent.rarity_map">module webtorrent.rarity_map</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.rarity_map.rarity_map" id="apidoc.element.webtorrent.rarity_map.rarity_map">
        function <span class="apidocSignatureSpan">webtorrent.</span>rarity_map
        <span class="apidocSignatureSpan">(torrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RarityMap(torrent) {
  var self = this

  self._torrent = torrent
  self._numPieces = torrent.pieces.length
  self._pieces = []

  self._onWire = function (wire) {
    self.recalculate()
    self._initWire(wire)
  }
  self._onWireHave = function (index) {
    self._pieces[index] += 1
  }
  self._onWireBitfield = function () {
    self.recalculate()
  }

  self._torrent.wires.forEach(function (wire) {
    self._initWire(wire)
  })
  self._torrent.on('wire', self._onWire)
  self.recalculate()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.rarity_map.prototype" id="apidoc.module.webtorrent.rarity_map.prototype">module webtorrent.rarity_map.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.rarity_map.prototype._cleanupWireEvents" id="apidoc.element.webtorrent.rarity_map.prototype._cleanupWireEvents">
        function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>_cleanupWireEvents
        <span class="apidocSignatureSpan">(wire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanupWireEvents = function (wire) {
  wire.removeListener('have', this._onWireHave)
  wire.removeListener('bitfield', this._onWireBitfield)
  if (wire._onClose) wire.removeListener('close', wire._onClose)
  wire._onClose = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}

RarityMap.prototype.destroy = function () {
var self = this
self._torrent.removeListener('wire', self._onWire)
self._torrent.wires.forEach(function (wire) {
  self.<span class="apidocCodeKeywordSpan">_cleanupWireEvents</span>(wire)
})
self._torrent = null
self._pieces = null

self._onWire = null
self._onWireHave = null
self._onWireBitfield = null
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.rarity_map.prototype._initWire" id="apidoc.element.webtorrent.rarity_map.prototype._initWire">
        function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>_initWire
        <span class="apidocSignatureSpan">(wire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initWire = function (wire) {
  var self = this

  wire._onClose = function () {
    self._cleanupWireEvents(wire)
    for (var i = 0; i &lt; this._numPieces; ++i) {
      self._pieces[i] -= wire.peerPieces.get(i)
    }
  }

  wire.on('have', self._onWireHave)
  wire.on('bitfield', self._onWireBitfield)
  wire.once('close', wire._onClose)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

self._torrent = torrent
self._numPieces = torrent.pieces.length
self._pieces = []

self._onWire = function (wire) {
  self.recalculate()
  self.<span class="apidocCodeKeywordSpan">_initWire</span>(wire)
}
self._onWireHave = function (index) {
  self._pieces[index] += 1
}
self._onWireBitfield = function () {
  self.recalculate()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.rarity_map.prototype.destroy" id="apidoc.element.webtorrent.rarity_map.prototype.destroy">
        function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  var self = this
  self._torrent.removeListener('wire', self._onWire)
  self._torrent.wires.forEach(function (wire) {
    self._cleanupWireEvents(wire)
  })
  self._torrent = null
  self._pieces = null

  self._onWire = null
  self._onWireHave = null
  self._onWireBitfield = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
var torrent = this.get(torrentId)
if (!torrent) return
this.torrents.splice(this.torrents.indexOf(torrent), 1)
torrent.<span class="apidocCodeKeywordSpan">destroy</span>(cb)
}

WebTorrent.prototype.address = function () {
if (!this.listening) return null
return this._tcpPool
  ? this._tcpPool.server.address()
  : { address: '0.0.0.0', family: 'IPv4', port: 0 }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.rarity_map.prototype.getRarestPiece" id="apidoc.element.webtorrent.rarity_map.prototype.getRarestPiece">
        function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>getRarestPiece
        <span class="apidocSignatureSpan">(pieceFilterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRarestPiece = function (pieceFilterFunc) {
  if (!pieceFilterFunc) pieceFilterFunc = trueFn

  var candidates = []
  var min = Infinity

  for (var i = 0; i &lt; this._numPieces; ++i) {
    if (!pieceFilterFunc(i)) continue

    var availability = this._pieces[i]
    if (availability === min) {
      candidates.push(i)
    } else if (availability &lt; min) {
      candidates = [ i ]
      min = availability
    }
  }

  if (candidates.length &gt; 0) {
    // if there are multiple pieces with the same availability, choose one randomly
    return candidates[Math.random() * candidates.length | 0]
  } else {
    return -1
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var end = next.to
  var len = end - start + 1
  var tried = {}
  var tries = 0
  var filter = genPieceFilterFunc(start, end, tried)

  while (tries &lt; len) {
    piece = self._rarityMap.<span class="apidocCodeKeywordSpan">getRarestPiece</span>(filter)
    if (piece &lt; 0) break
    if (self._request(wire, piece, false)) return
    tried[piece] = true
    tries += 1
  }
} else {
  for (piece = next.to; piece &gt;= next.from + next.offset; --piece) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.rarity_map.prototype.recalculate" id="apidoc.element.webtorrent.rarity_map.prototype.recalculate">
        function <span class="apidocSignatureSpan">webtorrent.rarity_map.prototype.</span>recalculate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recalculate = function () {
  var i
  for (i = 0; i &lt; this._numPieces; ++i) {
    this._pieces[i] = 0
  }

  var numWires = this._torrent.wires.length
  for (i = 0; i &lt; numWires; ++i) {
    var wire = this._torrent.wires[i]
    for (var j = 0; j &lt; this._numPieces; ++j) {
      this._pieces[j] += wire.peerPieces.get(j)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this

self._torrent = torrent
self._numPieces = torrent.pieces.length
self._pieces = []

self._onWire = function (wire) {
  self.<span class="apidocCodeKeywordSpan">recalculate</span>()
  self._initWire(wire)
}
self._onWireHave = function (index) {
  self._pieces[index] += 1
}
self._onWireBitfield = function () {
  self.recalculate()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.tcp_pool" id="apidoc.module.webtorrent.tcp_pool">module webtorrent.tcp_pool</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.tcp_pool.tcp_pool" id="apidoc.element.webtorrent.tcp_pool.tcp_pool">
        function <span class="apidocSignatureSpan">webtorrent.</span>tcp_pool
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TCPPool(client) {
  var self = this
  debug('create tcp pool (port %s)', client.torrentPort)

  self.server = net.createServer()
  self._client = client

  // Temporarily store incoming connections so they can be destroyed if the server is
  // closed before the connection is passed off to a Torrent.
  self._pendingConns = []

  self._onConnectionBound = function (conn) {
    self._onConnection(conn)
  }

  self._onListening = function () {
    self._client._onListening()
  }

  self._onError = function (err) {
    self._client._destroy(err)
  }

  self.server.on('connection', self._onConnectionBound)
  self.server.on('listening', self._onListening)
  self.server.on('error', self._onError)

  self.server.listen(client.torrentPort)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.tcp_pool.prototype" id="apidoc.module.webtorrent.tcp_pool.prototype">module webtorrent.tcp_pool.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.tcp_pool.prototype._onConnection" id="apidoc.element.webtorrent.tcp_pool.prototype._onConnection">
        function <span class="apidocSignatureSpan">webtorrent.tcp_pool.prototype.</span>_onConnection
        <span class="apidocSignatureSpan">(conn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onConnection = function (conn) {
  var self = this

  // If the connection has already been closed before the `connect` event is fired,
  // then `remoteAddress` will not be available, and we can't use this connection.
  // - Node.js issue: https://github.com/nodejs/node-v0.x-archive/issues/7566
  // - WebTorrent issue: https://github.com/feross/webtorrent/issues/398
  if (!conn.remoteAddress) {
    conn.on('error', noop)
    conn.destroy()
    return
  }

  self._pendingConns.push(conn)
  conn.once('close', cleanupPending)

  var peer = Peer.createTCPIncomingPeer(conn)

  var wire = peer.wire
  wire.once('handshake', onHandshake)

  function onHandshake (infoHash, peerId) {
    cleanupPending()

    var torrent = self._client.get(infoHash)
    if (torrent) {
      peer.swarm = torrent
      torrent._addIncomingPeer(peer)
      peer.onHandshake(infoHash, peerId)
    } else {
      var err = new Error(
        'Unexpected info hash ' + infoHash + ' from incoming peer ' + peer.id
      )
      peer.destroy(err)
    }
  }

  function cleanupPending () {
    conn.removeListener('close', cleanupPending)
    wire.removeListener('handshake', onHandshake)
    if (self._pendingConns) {
      arrayRemove(self._pendingConns, self._pendingConns.indexOf(conn))
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._client = client

// Temporarily store incoming connections so they can be destroyed if the server is
// closed before the connection is passed off to a Torrent.
self._pendingConns = []

self._onConnectionBound = function (conn) {
  self.<span class="apidocCodeKeywordSpan">_onConnection</span>(conn)
}

self._onListening = function () {
  self._client._onListening()
}

self._onError = function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.tcp_pool.prototype.destroy" id="apidoc.element.webtorrent.tcp_pool.prototype.destroy">
        function <span class="apidocSignatureSpan">webtorrent.tcp_pool.prototype.</span>destroy
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (cb) {
  var self = this
  debug('destroy tcp pool')

  self.server.removeListener('connection', self._onConnectionBound)
  self.server.removeListener('listening', self._onListening)
  self.server.removeListener('error', self._onError)

  // Destroy all open connection objects so server can close gracefully without waiting
  // for connection timeout or remote peer to disconnect.
  self._pendingConns.forEach(function (conn) {
    conn.on('error', noop)
    conn.destroy()
  })

  try {
    self.server.close(cb)
  } catch (err) {
    if (cb) process.nextTick(cb)
  }

  self.server = null
  self._client = null
  self._pendingConns = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
var torrent = this.get(torrentId)
if (!torrent) return
this.torrents.splice(this.torrents.indexOf(torrent), 1)
torrent.<span class="apidocCodeKeywordSpan">destroy</span>(cb)
}

WebTorrent.prototype.address = function () {
if (!this.listening) return null
return this._tcpPool
  ? this._tcpPool.server.address()
  : { address: '0.0.0.0', family: 'IPv4', port: 0 }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.torrent" id="apidoc.module.webtorrent.torrent">module webtorrent.torrent</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.torrent.torrent" id="apidoc.element.webtorrent.torrent.torrent">
        function <span class="apidocSignatureSpan">webtorrent.</span>torrent
        <span class="apidocSignatureSpan">(torrentId, client, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Torrent(torrentId, client, opts) {
  EventEmitter.call(this)

  this._debugId = 'unknown infohash'
  this.client = client

  this.announce = opts.announce
  this.urlList = opts.urlList

  this.path = opts.path
  this._store = opts.store || FSChunkStore
  this._getAnnounceOpts = opts.getAnnounceOpts

  this.strategy = opts.strategy || 'sequential'

  this.maxWebConns = opts.maxWebConns || 4

  this._rechokeNumSlots = (opts.uploads === false || opts.uploads === 0)
    ? 0
    : (+opts.uploads || 10)
  this._rechokeOptimisticWire = null
  this._rechokeOptimisticTime = 0
  this._rechokeIntervalId = null

  this.ready = false
  this.destroyed = false
  this.paused = false
  this.done = false

  this.metadata = null
  this.store = null
  this.files = []
  this.pieces = []

  this._amInterested = false
  this._selections = []
  this._critical = []

  this.wires = [] // open wires (added *after* handshake)

  this._queue = [] // queue of outgoing tcp peers to connect to
  this._peers = {} // connected peers (addr/peerId -&gt; Peer)
  this._peersLength = 0 // number of elements in `this._peers` (cache, for perf)

  // stats
  this.received = 0
  this.uploaded = 0
  this._downloadSpeed = speedometer()
  this._uploadSpeed = speedometer()

  // for cleanup
  this._servers = []
  this._xsRequests = []

  // TODO: remove this and expose a hook instead
  // optimization: don't recheck every file if it hasn't changed
  this._fileModtimes = opts.fileModtimes

  if (torrentId !== null) this._onTorrentId(torrentId)

  this._debug('new torrent')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.super_" id="apidoc.element.webtorrent.torrent.super_">
        function <span class="apidocSignatureSpan">webtorrent.torrent.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.torrent.prototype" id="apidoc.module.webtorrent.torrent.prototype">module webtorrent.torrent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._addIncomingPeer" id="apidoc.element.webtorrent.torrent.prototype._addIncomingPeer">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_addIncomingPeer
        <span class="apidocSignatureSpan">(peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addIncomingPeer = function (peer) {
  var self = this
  if (self.destroyed) return peer.destroy(new Error('torrent is destroyed'))
  if (self.paused) return peer.destroy(new Error('torrent is paused'))

  this._debug('add incoming peer %s', peer.id)

  self._peers[peer.id] = peer
  self._peersLength += 1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  function onHandshake (infoHash, peerId) {
cleanupPending()

var torrent = self._client.get(infoHash)
if (torrent) {
  peer.swarm = torrent
  torrent.<span class="apidocCodeKeywordSpan">_addIncomingPeer</span>(peer)
  peer.onHandshake(infoHash, peerId)
} else {
  var err = new Error(
    'Unexpected info hash ' + infoHash + ' from incoming peer ' + peer.id
  )
  peer.destroy(err)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._addPeer" id="apidoc.element.webtorrent.torrent.prototype._addPeer">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_addPeer
        <span class="apidocSignatureSpan">(peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addPeer = function (peer) {
  var self = this
  if (self.destroyed) {
    if (typeof peer !== 'string') peer.destroy()
    return null
  }
  if (typeof peer === 'string' &amp;&amp; !self._validAddr(peer)) {
    self._debug('ignoring peer: invalid %s', peer)
    return null
  }

  var id = (peer &amp;&amp; peer.id) || peer
  if (self._peers[id]) {
    self._debug('ignoring peer: duplicate (%s)', id)
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  if (self.paused) {
    self._debug('ignoring peer: torrent is paused')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  self._debug('add peer %s', id)

  var newPeer
  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    newPeer = Peer.createTCPOutgoingPeer(peer, self)
  } else {
    // `peer` is a WebRTC connection (simple-peer)
    newPeer = Peer.createWebRTCPeer(peer, self)
  }

  self._peers[newPeer.id] = newPeer
  self._peersLength += 1

  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    self._queue.push(newPeer)
    self._drain()
  }

  return newPeer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      self._debug('ignoring peer: blocked %s', peer)
      if (typeof peer !== 'string') peer.destroy()
      self.emit('blockedPeer', peer)
      return false
    }
  }

  var wasAdded = !!self.<span class="apidocCodeKeywordSpan">_addPeer</span>(peer)
  if (wasAdded) {
    self.emit('peer', peer)
  } else {
    self.emit('invalidPeer', peer)
  }
  return wasAdded
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._checkDone" id="apidoc.element.webtorrent.torrent.prototype._checkDone">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_checkDone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkDone = function () {
  var self = this
  if (self.destroyed) return

  // are any new files done?
  self.files.forEach(function (file) {
    if (file.done) return
    for (var i = file._startPiece; i &lt;= file._endPiece; ++i) {
      if (!self.bitfield.get(i)) return
    }
    file.done = true
    file.emit('done')
    self._debug('file done: ' + file.name)
  })

  // is the torrent done? (if all current selections are satisfied, or there are
  // no selections, then torrent is done)
  var done = true
  for (var i = 0; i &lt; self._selections.length; i++) {
    var selection = self._selections[i]
    for (var piece = selection.from; piece &lt;= selection.to; piece++) {
      if (!self.bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) break
  }
  if (!self.done &amp;&amp; done) {
    self.done = true
    self._debug('torrent done: ' + self.infoHash)
    self.emit('done')
  }
  self._gcSelections()

  return done
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (self.destroyed) return
self._debug('on store')

self.ready = true
self.emit('ready')

// Files may start out done if the file was already in the store
self.<span class="apidocCodeKeywordSpan">_checkDone</span>()

// In case any selections were made before torrent was ready
self._updateSelections()
}

Torrent.prototype.destroy = function (cb) {
var self = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._debug" id="apidoc.element.webtorrent.torrent.prototype._debug">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this.client._debugId + '] [' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.listening = false
self.torrentPort = opts.torrentPort || 0
self.dhtPort = opts.dhtPort || 0
self.tracker = opts.tracker !== undefined ? opts.tracker : {}
self.torrents = []
self.maxConns = Number(opts.maxConns) || 55

self.<span class="apidocCodeKeywordSpan">_debug</span>(
  'new webtorrent (peerId %s, nodeId %s, port %s)',
  self.peerId, self.nodeId, self.torrentPort
)

if (self.tracker) {
  if (typeof self.tracker !== 'object') self.tracker = {}
  if (opts.rtcConfig) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._destroy" id="apidoc.element.webtorrent.torrent.prototype._destroy">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_destroy
        <span class="apidocSignatureSpan">(err, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_destroy = function (err, cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self._debug('destroy')

  self.client._remove(self)

  clearInterval(self._rechokeIntervalId)

  self._xsRequests.forEach(function (req) {
    req.abort()
  })

  if (self._rarityMap) {
    self._rarityMap.destroy()
  }

  for (var id in self._peers) {
    self.removePeer(id)
  }

  self.files.forEach(function (file) {
    if (file instanceof File) file._destroy()
  })

  var tasks = self._servers.map(function (server) {
    return function (cb) {
      server.destroy(cb)
    }
  })

  if (self.discovery) {
    tasks.push(function (cb) {
      self.discovery.destroy(cb)
    })
  }

  if (self.store) {
    tasks.push(function (cb) {
      self.store.close(cb)
    })
  }

  parallel(tasks, cb)

  if (err) {
    // Torrent errors are emitted at `torrent.on('error')`. If there are no 'error'
    // event handlers on the torrent instance, then the error will be emitted at
    // `client.on('error')`. This prevents throwing an uncaught exception
    // (unhandled 'error' event), but it makes it impossible to distinguish client
    // errors versus torrent errors. Torrent errors are not fatal, and the client
    // is still usable afterwards. Therefore, always listen for errors in both
    // places (`client.on('error')` and `torrent.on('error')`).
    if (self.listenerCount('error') === 0) {
      self.client.emit('error', err)
    } else {
      self.emit('error', err)
    }
  }

  self.emit('close')

  self.client = null
  self.files = []
  self.discovery = null
  self.store = null
  self._rarityMap = null
  self._peers = null
  self._servers = null
  self._xsRequests = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self._uploadSpeed = speedometer()

  if (opts.dht !== false &amp;&amp; typeof DHT === 'function' /* browser exclude */) {
// use a single DHT instance for all torrents, so the routing table can be reused
self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))

self.dht.once('error', function (err) {
  self.<span class="apidocCodeKeywordSpan">_destroy</span>(err)
})

self.dht.once('listening', function () {
  var address = self.dht.address()
  if (address) self.dhtPort = address.port
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._drain" id="apidoc.element.webtorrent.torrent.prototype._drain">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_drain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_drain = function () {
  var self = this
  this._debug('_drain numConns %s maxConns %s', self._numConns, self.client.maxConns)
  if (typeof net.connect !== 'function' || self.destroyed || self.paused ||
      self._numConns &gt;= self.client.maxConns) {
    return
  }
  this._debug('drain (%s queued, %s/%s peers)', self._numQueued, self.numPeers, self.client.maxConns)

  var peer = self._queue.shift()
  if (!peer) return // queue could be empty

  this._debug('tcp connect attempt to %s', peer.addr)

  var parts = addrToIPPort(peer.addr)
  var opts = {
    host: parts[0],
    port: parts[1]
  }

  var conn = peer.conn = net.connect(opts)

  conn.once('connect', function () { peer.onConnect() })
  conn.once('error', function (err) { peer.destroy(err) })
  peer.startConnectTimeout()

  // When connection closes, attempt reconnect after timeout (with exponential backoff)
  conn.on('close', function () {
    if (self.destroyed) return

    // TODO: If torrent is done, do not try to reconnect after a timeout

    if (peer.retries &gt;= RECONNECT_WAIT.length) {
      self._debug(
        'conn %s closed: will not re-add (max %s attempts)',
        peer.addr, RECONNECT_WAIT.length
      )
      return
    }

    var ms = RECONNECT_WAIT[peer.retries]
    self._debug(
      'conn %s closed: will re-add to queue in %sms (attempt %s)',
      peer.addr, ms, peer.retries + 1
    )

    var reconnectTimeout = setTimeout(function reconnectTimeout () {
      var newPeer = self._addPeer(peer.addr)
      if (newPeer) newPeer.retries = peer.retries + 1
    }, ms)
    if (reconnectTimeout.unref) reconnectTimeout.unref()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

self._peers[newPeer.id] = newPeer
self._peersLength += 1

if (typeof peer === 'string') {
  // `peer` is an addr ("ip:port" string)
  self._queue.push(newPeer)
  self.<span class="apidocCodeKeywordSpan">_drain</span>()
}

return newPeer
}

Torrent.prototype.addWebSeed = function (url) {
if (this.destroyed) throw new Error('torrent is destroyed')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._gcSelections" id="apidoc.element.webtorrent.torrent.prototype._gcSelections">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_gcSelections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_gcSelections = function () {
  var self = this

  for (var i = 0; i &lt; self._selections.length; ++i) {
    var s = self._selections[i]
    var oldOffset = s.offset

    // check for newly downloaded pieces in selection
    while (self.bitfield.get(s.from + s.offset) &amp;&amp; s.from + s.offset &lt; s.to) {
      s.offset += 1
    }

    if (oldOffset !== s.offset) s.notify()
    if (s.to !== s.from + s.offset) continue
    if (!self.bitfield.get(s.from + s.offset)) continue

    self._selections.splice(i, 1) // remove fully downloaded selection
    i -= 1 // decrement i to offset splice

    s.notify()
    self._updateInterest()
  }

  if (!self._selections.length) self.emit('idle')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Called on selection changes.
*/
Torrent.prototype._updateSelections = function () {
 var self = this
 if (!self.ready || self.destroyed) return

 process.nextTick(function () {
   self.<span class="apidocCodeKeywordSpan">_gcSelections</span>()
 })
 self._updateInterest()
 self._update()
}

/**
* Garbage collect selections with respect to the store's current state.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._getMetadataFromServer" id="apidoc.element.webtorrent.torrent.prototype._getMetadataFromServer">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_getMetadataFromServer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getMetadataFromServer = function () {
  var self = this
  var urls = Array.isArray(self.xs) ? self.xs : [ self.xs ]

  var tasks = urls.map(function (url) {
    return function (cb) {
      getMetadataFromURL(url, cb)
    }
  })
  parallel(tasks)

  function getMetadataFromURL (url, cb) {
    if (url.indexOf('http://') !== 0 &amp;&amp; url.indexOf('https://') !== 0) {
      self.emit('warning', new Error('skipping non-http xs param: ' + url))
      return cb(null)
    }

    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': USER_AGENT
      }
    }
    var req
    try {
      req = get.concat(opts, onResponse)
    } catch (err) {
      self.emit('warning', new Error('skipping invalid url xs param: ' + url))
      return cb(null)
    }

    self._xsRequests.push(req)

    function onResponse (err, res, torrent) {
      if (self.destroyed) return cb(null)
      if (self.metadata) return cb(null)

      if (err) {
        self.emit('warning', new Error('http error from xs param: ' + url))
        return cb(null)
      }
      if (res.statusCode !== 200) {
        self.emit('warning', new Error('non-200 status code ' + res.statusCode + ' from xs param: ' + url))
        return cb(null)
      }

      var parsedTorrent
      try {
        parsedTorrent = parseTorrent(torrent)
      } catch (err) {}

      if (!parsedTorrent) {
        self.emit('warning', new Error('got invalid torrent file from xs param: ' + url))
        return cb(null)
      }

      if (parsedTorrent.infoHash !== self.infoHash) {
        self.emit('warning', new Error('got torrent file with incorrect info hash from xs param: ' + url))
        return cb(null)
      }

      self._onMetadata(parsedTorrent)
      cb(null)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (self.info) {
  // if full metadata was included in initial torrent id, use it immediately. Otherwise,
  // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
  self._onMetadata(self)
} else if (self.xs) {
  self.<span class="apidocCodeKeywordSpan">_getMetadataFromServer</span>()
}
}

Torrent.prototype._getMetadataFromServer = function () {
var self = this
var urls = Array.isArray(self.xs) ? self.xs : [ self.xs ]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._hotswap" id="apidoc.element.webtorrent.torrent.prototype._hotswap">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_hotswap
        <span class="apidocSignatureSpan">(wire, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_hotswap = function (wire, index) {
  var self = this

  var speed = wire.downloadSpeed()
  if (speed &lt; Piece.BLOCK_LENGTH) return false
  if (!self._reservations[index]) return false

  var r = self._reservations[index]
  if (!r) {
    return false
  }

  var minSpeed = Infinity
  var minWire

  var i
  for (i = 0; i &lt; r.length; i++) {
    var otherWire = r[i]
    if (!otherWire || otherWire === wire) continue

    var otherSpeed = otherWire.downloadSpeed()
    if (otherSpeed &gt;= SPEED_THRESHOLD) continue
    if (2 * otherSpeed &gt; speed || otherSpeed &gt; minSpeed) continue

    minWire = otherWire
    minSpeed = otherSpeed
  }

  if (!minWire) return false

  for (i = 0; i &lt; r.length; i++) {
    if (r[i] === minWire) r[i] = null
  }

  for (i = 0; i &lt; minWire.requests.length; i++) {
    var req = minWire.requests[i]
    if (req.piece !== index) continue

    self.pieces[index].cancel((req.offset / Piece.BLOCK_LENGTH) | 0)
  }

  self.emit('hotswap', minWire, wire, index)
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (numRequests &gt;= maxOutstandingRequests) return false
// var endGame = (wire.requests.length === 0 &amp;&amp; self.store.numMissing &lt; 30)

var piece = self.pieces[index]
var reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()

if (reservation === -1 &amp;&amp; hotswap &amp;&amp; self.<span class="apidocCodeKeywordSpan">_hotswap</span>(wire, index)) {
  reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()
}
if (reservation === -1) return false

var r = self._reservations[index]
if (!r) r = self._reservations[index] = []
var i = r.indexOf(null)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._markVerified" id="apidoc.element.webtorrent.torrent.prototype._markVerified">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_markVerified
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_markVerified = function (index) {
  this.pieces[index] = null
  this._reservations[index] = null
  this.bitfield.set(index, true)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return fileModtimes[index] === self._fileModtimes[index]
    }).every(function (x) {
      return x
    })

    if (unchanged) {
      for (var index = 0; index &lt; self.pieces.length; index++) {
        self.<span class="apidocCodeKeywordSpan">_markVerified</span>(index)
      }
      self._onStore()
    } else {
      self._verifyPieces()
    }
  })
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._onListening" id="apidoc.element.webtorrent.torrent.prototype._onListening">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onListening
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onListening = function () {
  var self = this
  if (self.discovery || self.destroyed) return

  var trackerOpts = self.client.tracker
  if (trackerOpts) {
    trackerOpts = extend(self.client.tracker, {
      getAnnounceOpts: function () {
        var opts = {
          uploaded: self.uploaded,
          downloaded: self.downloaded,
          left: Math.max(self.length - self.downloaded, 0)
        }
        if (self.client.tracker.getAnnounceOpts) {
          extendMutable(opts, self.client.tracker.getAnnounceOpts())
        }
        if (self._getAnnounceOpts) {
          // TODO: consider deprecating this, as it's redundant with the former case
          extendMutable(opts, self._getAnnounceOpts())
        }
        return opts
      }
    })
  }

  // begin discovering peers via DHT and trackers
  self.discovery = new Discovery({
    infoHash: self.infoHash,
    announce: self.announce,
    peerId: self.client.peerId,
    dht: !self.private &amp;&amp; self.client.dht,
    tracker: trackerOpts,
    port: self.client.torrentPort,
    userAgent: USER_AGENT
  })

  self.discovery.on('error', onError)
  self.discovery.on('peer', onPeer)
  self.discovery.on('trackerAnnounce', onTrackerAnnounce)
  self.discovery.on('dhtAnnounce', onDHTAnnounce)
  self.discovery.on('warning', onWarning)

  function onError (err) {
    self._destroy(err)
  }

  function onPeer (peer) {
    // Don't create new outgoing TCP connections when torrent is done
    if (typeof peer === 'string' &amp;&amp; self.done) return
    self.addPeer(peer)
  }

  function onTrackerAnnounce () {
    self.emit('trackerAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'tracker')
  }

  function onDHTAnnounce () {
    self.emit('dhtAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'dht')
  }

  function onWarning (err) {
    self.emit('warning', err)
  }

  if (self.info) {
    // if full metadata was included in initial torrent id, use it immediately. Otherwise,
    // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
    self._onMetadata(self)
  } else if (self.xs) {
    self._getMetadataFromServer()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

if (typeof TCPPool === 'function') {
  self._tcpPool = new TCPPool(self)
} else {
  process.nextTick(function () {
    self.<span class="apidocCodeKeywordSpan">_onListening</span>()
  })
}

// stats
self._downloadSpeed = speedometer()
self._uploadSpeed = speedometer()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._onMetadata" id="apidoc.element.webtorrent.torrent.prototype._onMetadata">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onMetadata
        <span class="apidocSignatureSpan">(metadata)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onMetadata = function (metadata) {
  var self = this
  if (self.metadata || self.destroyed) return
  self._debug('got metadata')

  self._xsRequests.forEach(function (req) {
    req.abort()
  })
  self._xsRequests = []

  var parsedTorrent
  if (metadata &amp;&amp; metadata.infoHash) {
    // `metadata` is a parsed torrent (from parse-torrent module)
    parsedTorrent = metadata
  } else {
    try {
      parsedTorrent = parseTorrent(metadata)
    } catch (err) {
      return self._destroy(err)
    }
  }

  self._processParsedTorrent(parsedTorrent)
  self.metadata = self.torrentFile

  // add web seed urls (BEP19)
  if (self.client.enableWebSeeds) {
    self.urlList.forEach(function (url) {
      self.addWebSeed(url)
    })
  }

  // start off selecting the entire torrent with low priority
  if (self.pieces.length !== 0) {
    self.select(0, self.pieces.length - 1, false)
  }

  self._rarityMap = new RarityMap(self)

  self.store = new ImmediateChunkStore(
    new self._store(self.pieceLength, {
      torrent: {
        infoHash: self.infoHash
      },
      files: self.files.map(function (file) {
        return {
          path: path.join(self.path, file.path),
          length: file.length,
          offset: file.offset
        }
      }),
      length: self.length
    })
  )

  self.files = self.files.map(function (file) {
    return new File(self, file)
  })

  self._hashes = self.pieces

  self.pieces = self.pieces.map(function (hash, i) {
    var pieceLength = (i === self.pieces.length - 1)
      ? self.lastPieceLength
      : self.pieceLength
    return new Piece(pieceLength)
  })

  self._reservations = self.pieces.map(function () {
    return []
  })

  self.bitfield = new BitField(self.pieces.length)

  self.wires.forEach(function (wire) {
    // If we didn't have the metadata at the time ut_metadata was initialized for this
    // wire, we still want to make it available to the peer in case they request it.
    if (wire.ut_metadata) wire.ut_metadata.setMetadata(self.metadata)

    self._onWireWithMetadata(wire)
  })

  self._debug('verifying existing torrent data')
  if (self._fileModtimes &amp;&amp; self._store === FSChunkStore) {
    // don't verify if the files haven't been modified since we last checked
    self.getFileModtimes(function (err, fileModtimes) {
      if (err) return self._destroy(err)

      var unchanged = self.files.map(function (_, index) {
        return fileModtimes[index] === self._fileModtimes[index]
      }).every(function (x) {
        return x
      })

      if (unchanged) {
        for (var index = 0; index &lt; self.pieces.length; index++) {
          self._markVerified(index)
        }
        self._onStore()
      } else {
        self._verifyPieces()
      }
    })
  } else {
    self._verifyPieces()
  }

  self.emit('metadata')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function onWarning (err) {
  self.emit('warning', err)
}

if (self.info) {
  // if full metadata was included in initial torrent id, use it immediately. Otherwise,
  // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
  self.<span class="apidocCodeKeywordSpan">_onMetadata</span>(self)
} else if (self.xs) {
  self._getMetadataFromServer()
}
}

Torrent.prototype._getMetadataFromServer = function () {
var self = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._onParsedTorrent" id="apidoc.element.webtorrent.torrent.prototype._onParsedTorrent">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onParsedTorrent
        <span class="apidocSignatureSpan">(parsedTorrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onParsedTorrent = function (parsedTorrent) {
  var self = this
  if (self.destroyed) return

  self._processParsedTorrent(parsedTorrent)

  if (!self.infoHash) {
    return self._destroy(new Error('Malformed torrent data: No info hash'))
  }

  if (!self.path) self.path = path.join(TMP, self.infoHash)

  self._rechokeIntervalId = setInterval(function () {
    self._rechoke()
  }, RECHOKE_INTERVAL)
  if (self._rechokeIntervalId.unref) self._rechokeIntervalId.unref()

  // Private 'infoHash' event allows client.add to check for duplicate torrents and
  // destroy them before the normal 'infoHash' event is emitted. Prevents user
  // applications from needing to deal with duplicate 'infoHash' events.
  self.emit('_infoHash', self.infoHash)
  if (self.destroyed) return

  self.emit('infoHash', self.infoHash)
  if (self.destroyed) return // user might destroy torrent in event handler

  if (self.client.listening) {
    self._onListening()
  } else {
    self.client.once('listening', function () {
      self._onListening()
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try { parsedTorrent = parseTorrent(torrentId) } catch (err) {}
if (parsedTorrent) {
  // Attempt to set infoHash property synchronously
  self.infoHash = parsedTorrent.infoHash
  self._debugId = parsedTorrent.infoHash.toString('hex').substring(0, 7)
  process.nextTick(function () {
    if (self.destroyed) return
    self.<span class="apidocCodeKeywordSpan">_onParsedTorrent</span>(parsedTorrent)
  })
} else {
  // If torrentId failed to parse, it could be in a form that requires an async
  // operation, i.e. http/https link, filesystem path, or Blob.
  parseTorrent.remote(torrentId, function (err, parsedTorrent) {
    if (self.destroyed) return
    if (err) return self._destroy(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._onStore" id="apidoc.element.webtorrent.torrent.prototype._onStore">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onStore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onStore = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on store')

  self.ready = true
  self.emit('ready')

  // Files may start out done if the file was already in the store
  self._checkDone()

  // In case any selections were made before torrent was ready
  self._updateSelections()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return x
    })

    if (unchanged) {
      for (var index = 0; index &lt; self.pieces.length; index++) {
        self._markVerified(index)
      }
      self.<span class="apidocCodeKeywordSpan">_onStore</span>()
    } else {
      self._verifyPieces()
    }
  })
} else {
  self._verifyPieces()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._onTorrentId" id="apidoc.element.webtorrent.torrent.prototype._onTorrentId">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onTorrentId
        <span class="apidocSignatureSpan">(torrentId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onTorrentId = function (torrentId) {
  var self = this
  if (self.destroyed) return

  var parsedTorrent
  try { parsedTorrent = parseTorrent(torrentId) } catch (err) {}
  if (parsedTorrent) {
    // Attempt to set infoHash property synchronously
    self.infoHash = parsedTorrent.infoHash
    self._debugId = parsedTorrent.infoHash.toString('hex').substring(0, 7)
    process.nextTick(function () {
      if (self.destroyed) return
      self._onParsedTorrent(parsedTorrent)
    })
  } else {
    // If torrentId failed to parse, it could be in a form that requires an async
    // operation, i.e. http/https link, filesystem path, or Blob.
    parseTorrent.remote(torrentId, function (err, parsedTorrent) {
      if (self.destroyed) return
      if (err) return self._destroy(err)
      self._onParsedTorrent(parsedTorrent)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (self.destroyed) return
      if (err) return torrent._destroy(err)

      var existingTorrent = self.get(torrentBuf)
      if (existingTorrent) {
        torrent._destroy(new Error('Cannot add duplicate torrent ' + existingTorrent.infoHash))
      } else {
        torrent.<span class="apidocCodeKeywordSpan">_onTorrentId</span>(torrentBuf)
      }
    })
  })
})

function onTorrent (torrent) {
  var tasks = [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._onWire" id="apidoc.element.webtorrent.torrent.prototype._onWire">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onWire
        <span class="apidocSignatureSpan">(wire, addr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onWire = function (wire, addr) {
  var self = this
  self._debug('got wire %s (%s)', wire._debugId, addr || 'Unknown')

  wire.on('download', function (downloaded) {
    if (self.destroyed) return
    self.received += downloaded
    self._downloadSpeed(downloaded)
    self.client._downloadSpeed(downloaded)
    self.emit('download', downloaded)
    self.client.emit('download', downloaded)
  })

  wire.on('upload', function (uploaded) {
    if (self.destroyed) return
    self.uploaded += uploaded
    self._uploadSpeed(uploaded)
    self.client._uploadSpeed(uploaded)
    self.emit('upload', uploaded)
    self.client.emit('upload', uploaded)
  })

  self.wires.push(wire)

  if (addr) {
    // Sometimes RTCPeerConnection.getStats() doesn't return an ip:port for peers
    var parts = addrToIPPort(addr)
    wire.remoteAddress = parts[0]
    wire.remotePort = parts[1]
  }

  // When peer sends PORT message, add that DHT node to routing table
  if (self.client.dht &amp;&amp; self.client.dht.listening) {
    wire.on('port', function (port) {
      if (self.destroyed || self.client.dht.destroyed) {
        return
      }
      if (!wire.remoteAddress) {
        return self._debug('ignoring PORT from peer with no address')
      }
      if (port === 0 || port &gt; 65536) {
        return self._debug('ignoring invalid PORT from peer')
      }

      self._debug('port: %s (from %s)', port, addr)
      self.client.dht.addNode({ host: wire.remoteAddress, port: port })
    })
  }

  wire.on('timeout', function () {
    self._debug('wire timeout (%s)', addr)
    // TODO: this might be destroying wires too eagerly
    wire.destroy()
  })

  // Timeout for piece requests to this peer
  wire.setTimeout(PIECE_TIMEOUT, true)

  // Send KEEP-ALIVE (every 60s) so peers will not disconnect the wire
  wire.setKeepAlive(true)

  // use ut_metadata extension
  wire.use(utMetadata(self.metadata))

  wire.ut_metadata.on('warning', function (err) {
    self._debug('ut_metadata warning: %s', err.message)
  })

  if (!self.metadata) {
    wire.ut_metadata.on('metadata', function (metadata) {
      self._debug('got metadata via ut_metadata')
      self._onMetadata(metadata)
    })
    wire.ut_metadata.fetch()
  }

  // use ut_pex extension if the torrent is not flagged as private
  if (typeof utPex === 'function' &amp;&amp; !self.private) {
    wire.use(utPex())

    wire.ut_pex.on('peer', function (peer) {
      // Only add potential new peers when we're not seeding
      if (self.done) return
      self._debug('ut_pex: got peer: %s (from %s)', peer, addr)
      self.addPeer(peer)
    })

    wire.ut_pex.on('dropped', function (peer) {
      // the remote peer believes a given peer has been dropped from the torrent swarm.
      // if we're not currently connected to it, then remove it from the queue.
      var peerObj = self._peers[peer]
      if (peerObj &amp;&amp; !peerObj.connected) {
        self._debug('ut_pex: dropped peer: %s (from %s)', peer, addr)
        self.removePeer(peer)
      }
    })

    wire.once('close', function () {
      // Stop sending updates to remote peer
      wire.ut_pex.reset()
    })
  }

  // Hook to allow user-defined `bittorrent-protocol` extensions
  // More info: https://github.com/feross/bittorrent-protocol#extension-api
  self.emit('wire', wire, addr)

  if (self.metadata) {
    process.nextTick(function () {
      // This allows wire.handshake() to be called (by Peer.onHandshake) before any
      // messages get sent on the wire
      self._onWireWithMetadata(wire)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  self.retries = 0

  var addr = self.addr
  if (!addr &amp;&amp; self.conn.remoteAddress) {
    addr = self.conn.remoteAddress + ':' + self.conn.remotePort
  }
  self.swarm.<span class="apidocCodeKeywordSpan">_onWire</span>(self.wire, addr)

  // swarm could be destroyed in user's 'wire' event handler
  if (!self.swarm || self.swarm.destroyed) return

  if (!self.sentHandshake) self.handshake()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._onWireWithMetadata" id="apidoc.element.webtorrent.torrent.prototype._onWireWithMetadata">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_onWireWithMetadata
        <span class="apidocSignatureSpan">(wire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onWireWithMetadata = function (wire) {
  var self = this
  var timeoutId = null

  function onChokeTimeout () {
    if (self.destroyed || wire.destroyed) return

    if (self._numQueued &gt; 2 * (self._numConns - self.numPeers) &amp;&amp;
      wire.amInterested) {
      wire.destroy()
    } else {
      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
      if (timeoutId.unref) timeoutId.unref()
    }
  }

  var i
  function updateSeedStatus () {
    if (wire.peerPieces.buffer.length !== self.bitfield.buffer.length) return
    for (i = 0; i &lt; self.pieces.length; ++i) {
      if (!wire.peerPieces.get(i)) return
    }
    wire.isSeeder = true
    wire.choke() // always choke seeders
  }

  wire.on('bitfield', function () {
    updateSeedStatus()
    self._update()
  })

  wire.on('have', function () {
    updateSeedStatus()
    self._update()
  })

  wire.once('interested', function () {
    wire.unchoke()
  })

  wire.once('close', function () {
    clearTimeout(timeoutId)
  })

  wire.on('choke', function () {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
    if (timeoutId.unref) timeoutId.unref()
  })

  wire.on('unchoke', function () {
    clearTimeout(timeoutId)
    self._update()
  })

  wire.on('request', function (index, offset, length, cb) {
    if (length &gt; MAX_BLOCK_LENGTH) {
      // Per spec, disconnect from peers that request &gt;128KB
      return wire.destroy()
    }
    if (self.pieces[index]) return
    self.store.get(index, { offset: offset, length: length }, cb)
  })

  wire.bitfield(self.bitfield) // always send bitfield (required)
  wire.interested() // always start out interested

  // Send PORT message to peers that support DHT
  if (wire.peerExtensions.dht &amp;&amp; self.client.dht &amp;&amp; self.client.dht.listening) {
    wire.port(self.client.dht.address().port)
  }

  if (wire.type !== 'webSeed') { // do not choke on webseeds
    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
    if (timeoutId.unref) timeoutId.unref()
  }

  wire.isSeeder = false
  updateSeedStatus()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.bitfield = new BitField(self.pieces.length)

self.wires.forEach(function (wire) {
  // If we didn't have the metadata at the time ut_metadata was initialized for this
  // wire, we still want to make it available to the peer in case they request it.
  if (wire.ut_metadata) wire.ut_metadata.setMetadata(self.metadata)

  self.<span class="apidocCodeKeywordSpan">_onWireWithMetadata</span>(wire)
})

self._debug('verifying existing torrent data')
if (self._fileModtimes &amp;&amp; self._store === FSChunkStore) {
  // don't verify if the files haven't been modified since we last checked
  self.getFileModtimes(function (err, fileModtimes) {
    if (err) return self._destroy(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._processParsedTorrent" id="apidoc.element.webtorrent.torrent.prototype._processParsedTorrent">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_processParsedTorrent
        <span class="apidocSignatureSpan">(parsedTorrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processParsedTorrent = function (parsedTorrent) {
  this._debugId = parsedTorrent.infoHash.toString('hex').substring(0, 7)

  if (this.announce) {
    // Allow specifying trackers via `opts` parameter
    parsedTorrent.announce = parsedTorrent.announce.concat(this.announce)
  }

  if (this.client.tracker &amp;&amp; global.WEBTORRENT_ANNOUNCE &amp;&amp; !this.private) {
    // So `webtorrent-hybrid` can force specific trackers to be used
    parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE)
  }

  if (this.urlList) {
    // Allow specifying web seeds via `opts` parameter
    parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList)
  }

  uniq(parsedTorrent.announce)
  uniq(parsedTorrent.urlList)

  extendMutable(this, parsedTorrent)

  this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent)
  this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}

Torrent.prototype._onParsedTorrent = function (parsedTorrent) {
var self = this
if (self.destroyed) return

self.<span class="apidocCodeKeywordSpan">_processParsedTorrent</span>(parsedTorrent)

if (!self.infoHash) {
  return self._destroy(new Error('Malformed torrent data: No info hash'))
}

if (!self.path) self.path = path.join(TMP, self.infoHash)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._rechoke" id="apidoc.element.webtorrent.torrent.prototype._rechoke">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_rechoke
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_rechoke = function () {
  var self = this
  if (!self.ready) return

  if (self._rechokeOptimisticTime &gt; 0) self._rechokeOptimisticTime -= 1
  else self._rechokeOptimisticWire = null

  var peers = []

  self.wires.forEach(function (wire) {
    if (!wire.isSeeder &amp;&amp; wire !== self._rechokeOptimisticWire) {
      peers.push({
        wire: wire,
        downloadSpeed: wire.downloadSpeed(),
        uploadSpeed: wire.uploadSpeed(),
        salt: Math.random(),
        isChoked: true
      })
    }
  })

  peers.sort(rechokeSort)

  var unchokeInterested = 0
  var i = 0
  for (; i &lt; peers.length &amp;&amp; unchokeInterested &lt; self._rechokeNumSlots; ++i) {
    peers[i].isChoked = false
    if (peers[i].wire.peerInterested) unchokeInterested += 1
  }

  // Optimistically unchoke a peer
  if (!self._rechokeOptimisticWire &amp;&amp; i &lt; peers.length &amp;&amp; self._rechokeNumSlots) {
    var candidates = peers.slice(i).filter(function (peer) { return peer.wire.peerInterested })
    var optimistic = candidates[randomInt(candidates.length)]

    if (optimistic) {
      optimistic.isChoked = false
      self._rechokeOptimisticWire = optimistic.wire
      self._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION
    }
  }

  // Unchoke best peers
  peers.forEach(function (peer) {
    if (peer.wire.amChoking !== peer.isChoked) {
      if (peer.isChoked) peer.wire.choke()
      else peer.wire.unchoke()
    }
  })

  function rechokeSort (peerA, peerB) {
    // Prefer higher download speed
    if (peerA.downloadSpeed !== peerB.downloadSpeed) {
      return peerB.downloadSpeed - peerA.downloadSpeed
    }

    // Prefer higher upload speed
    if (peerA.uploadSpeed !== peerB.uploadSpeed) {
      return peerB.uploadSpeed - peerA.uploadSpeed
    }

    // Prefer unchoked
    if (peerA.wire.amChoking !== peerB.wire.amChoking) {
      return peerA.wire.amChoking ? 1 : -1
    }

    // Random order
    return peerA.salt - peerB.salt
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!self.infoHash) {
  return self._destroy(new Error('Malformed torrent data: No info hash'))
}

if (!self.path) self.path = path.join(TMP, self.infoHash)

self._rechokeIntervalId = setInterval(function () {
  self.<span class="apidocCodeKeywordSpan">_rechoke</span>()
}, RECHOKE_INTERVAL)
if (self._rechokeIntervalId.unref) self._rechokeIntervalId.unref()

// Private 'infoHash' event allows client.add to check for duplicate torrents and
// destroy them before the normal 'infoHash' event is emitted. Prevents user
// applications from needing to deal with duplicate 'infoHash' events.
self.emit('_infoHash', self.infoHash)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._request" id="apidoc.element.webtorrent.torrent.prototype._request">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_request
        <span class="apidocSignatureSpan">(wire, index, hotswap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_request = function (wire, index, hotswap) {
  var self = this
  var numRequests = wire.requests.length
  var isWebSeed = wire.type === 'webSeed'

  if (self.bitfield.get(index)) return false

  var maxOutstandingRequests = isWebSeed
    ? Math.min(
        getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength),
        self.maxWebConns
      )
    : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  if (numRequests &gt;= maxOutstandingRequests) return false
  // var endGame = (wire.requests.length === 0 &amp;&amp; self.store.numMissing &lt; 30)

  var piece = self.pieces[index]
  var reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()

  if (reservation === -1 &amp;&amp; hotswap &amp;&amp; self._hotswap(wire, index)) {
    reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()
  }
  if (reservation === -1) return false

  var r = self._reservations[index]
  if (!r) r = self._reservations[index] = []
  var i = r.indexOf(null)
  if (i === -1) i = r.length
  r[i] = wire

  var chunkOffset = piece.chunkOffset(reservation)
  var chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation)

  wire.request(index, chunkOffset, chunkLength, function onChunk (err, chunk) {
    // TODO: what is this for?
    if (!self.ready) return self.once('ready', function () { onChunk(err, chunk) })

    if (r[i] === wire) r[i] = null

    if (piece !== self.pieces[index]) return onUpdateTick()

    if (err) {
      self._debug(
        'error getting piece %s (offset: %s length: %s) from %s: %s',
        index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort,
        err.message
      )
      isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation)
      onUpdateTick()
      return
    }

    self._debug(
      'got piece %s (offset: %s length: %s) from %s',
      index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort
    )

    if (!piece.set(reservation, chunk, wire)) return onUpdateTick()

    var buf = piece.flush()

    // TODO: might need to set self.pieces[index] = null here since sha1 is async

    sha1(buf, function (hash) {
      if (self.destroyed) return

      if (hash === self._hashes[index]) {
        if (!self.pieces[index]) return
        self._debug('piece verified %s', index)

        self.pieces[index] = null
        self._reservations[index] = null
        self.bitfield.set(index, true)

        self.store.put(index, buf)

        self.wires.forEach(function (wire) {
          wire.have(index)
        })

        // We also check `self.destroyed` since `torrent.destroy()` could have been
        // called in the `torrent.on('done')` handler, triggered by `_checkDone()`.
        if (self._checkDone() &amp;&amp; !self.destroyed) self.discovery.complete()
      } else {
        self.pieces[index] = new Piece(piece.length)
        self.emit('warning', new Error('Piece ' + index + ' failed verification'))
      }
      onUpdateTick()
    })
  })

  function onUpdateTick () {
    process.nextTick(function () { self._update() })
  }

  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var tried = {}
  var tries = 0
  var filter = genPieceFilterFunc(start, end, tried)

  while (tries &lt; len) {
    piece = self._rarityMap.getRarestPiece(filter)
    if (piece &lt; 0) break
    if (self.<span class="apidocCodeKeywordSpan">_request</span>(wire, piece, false)) return
    tried[piece] = true
    tries += 1
  }
} else {
  for (piece = next.to; piece &gt;= next.from + next.offset; --piece) {
    if (!wire.peerPieces.get(piece)) continue
    if (self._request(wire, piece, false)) return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._update" id="apidoc.element.webtorrent.torrent.prototype._update">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_update
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_update = function () {
  var self = this
  if (self.destroyed) return

  // update wires in random order for better request distribution
  var ite = randomIterate(self.wires)
  var wire
  while ((wire = ite())) {
    self._updateWire(wire)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  wire.isSeeder = true
  wire.choke() // always choke seeders
}

wire.on('bitfield', function () {
  updateSeedStatus()
  self.<span class="apidocCodeKeywordSpan">_update</span>()
})

wire.on('have', function () {
  updateSeedStatus()
  self._update()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._updateInterest" id="apidoc.element.webtorrent.torrent.prototype._updateInterest">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_updateInterest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateInterest = function () {
  var self = this

  var prev = self._amInterested
  self._amInterested = !!self._selections.length

  self.wires.forEach(function (wire) {
    // TODO: only call wire.interested if the wire has at least one piece we need
    if (self._amInterested) wire.interested()
    else wire.uninterested()
  })

  if (prev === self._amInterested) return
  if (self._amInterested) self.emit('interested')
  else self.emit('uninterested')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Torrent.prototype._updateSelections = function () {
  var self = this
  if (!self.ready || self.destroyed) return

  process.nextTick(function () {
    self._gcSelections()
  })
  self.<span class="apidocCodeKeywordSpan">_updateInterest</span>()
  self._update()
}

/**
 * Garbage collect selections with respect to the store's current state.
 */
Torrent.prototype._gcSelections = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._updateSelections" id="apidoc.element.webtorrent.torrent.prototype._updateSelections">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_updateSelections
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateSelections = function () {
  var self = this
  if (!self.ready || self.destroyed) return

  process.nextTick(function () {
    self._gcSelections()
  })
  self._updateInterest()
  self._update()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.ready = true
  self.emit('ready')

  // Files may start out done if the file was already in the store
  self._checkDone()

  // In case any selections were made before torrent was ready
  self.<span class="apidocCodeKeywordSpan">_updateSelections</span>()
}

Torrent.prototype.destroy = function (cb) {
  var self = this
  self._destroy(null, cb)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._updateWire" id="apidoc.element.webtorrent.torrent.prototype._updateWire">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_updateWire
        <span class="apidocSignatureSpan">(wire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateWire = function (wire) {
  var self = this

  if (wire.peerChoking) return
  if (!wire.downloaded) return validateWire()

  var minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION)
  if (wire.requests.length &gt;= minOutstandingRequests) return
  var maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  trySelectWire(false) || trySelectWire(true)

  function genPieceFilterFunc (start, end, tried, rank) {
    return function (i) {
      return i &gt;= start &amp;&amp; i &lt;= end &amp;&amp; !(i in tried) &amp;&amp; wire.peerPieces.get(i) &amp;&amp; (!rank || rank(i))
    }
  }

  // TODO: Do we need both validateWire and trySelectWire?
  function validateWire () {
    if (wire.requests.length) return

    var i = self._selections.length
    while (i--) {
      var next = self._selections[i]
      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried)

        while (tries &lt; len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece &lt; 0) break
          if (self._request(wire, piece, false)) return
          tried[piece] = true
          tries += 1
        }
      } else {
        for (piece = next.to; piece &gt;= next.from + next.offset; --piece) {
          if (!wire.peerPieces.get(piece)) continue
          if (self._request(wire, piece, false)) return
        }
      }
    }

    // TODO: wire failed to validate as useful; should we close it?
    // probably not, since 'have' and 'bitfield' messages might be coming
  }

  function speedRanker () {
    var speed = wire.downloadSpeed() || 1
    if (speed &gt; SPEED_THRESHOLD) return function () { return true }

    var secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed
    var tries = 10
    var ptr = 0

    return function (index) {
      if (!tries || self.bitfield.get(index)) return true

      var missing = self.pieces[index].missing

      for (; ptr &lt; self.wires.length; ptr++) {
        var otherWire = self.wires[ptr]
        var otherSpeed = otherWire.downloadSpeed()

        if (otherSpeed &lt; SPEED_THRESHOLD) continue
        if (otherSpeed &lt;= speed) continue
        if (!otherWire.peerPieces.get(index)) continue
        if ((missing -= otherSpeed * secs) &gt; 0) continue

        tries--
        return false
      }

      return true
    }
  }

  function shufflePriority (i) {
    var last = i
    for (var j = i; j &lt; self._selections.length &amp;&amp; self._selections[j].priority; j++) {
      last = j
    }
    var tmp = self._selections[i]
    self._selections[i] = self._selections[last]
    self._selections[last] = tmp
  }

  function trySelectWire (hotswap) {
    if (wire.requests.length &gt;= maxOutstandingRequests) return true
    var rank = speedRanker()

    for (var i = 0; i &lt; self._selections.length; i++) {
      var next = self._selections[i]

      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried, rank)

        while (tries &lt; len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece &lt; 0) break

          // request all non-reserved blocks in this piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length &lt; maxOutstandingRequests) {
            tried[piece] = true
            tries++
            continue
          }

          if (next.priority) shufflePriority(i)
          return true
        }
      } else {
        for (piece = next.from + next.offset; piece &lt;= next.to; piece++) {
          if (!wire.peerPieces.get(piece) || !rank(piece)) continue

          // request all non-reserved blocks in piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length &lt; maxOutstan ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this
  if (self.destroyed) return

  // update wires in random order for better request distribution
  var ite = randomIterate(self.wires)
  var wire
  while ((wire = ite())) {
    self.<span class="apidocCodeKeywordSpan">_updateWire</span>(wire)
  }
}

/**
 * Attempts to update a peer's requests
 */
Torrent.prototype._updateWire = function (wire) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._validAddr" id="apidoc.element.webtorrent.torrent.prototype._validAddr">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_validAddr
        <span class="apidocSignatureSpan">(addr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_validAddr = function (addr) {
  var parts
  try {
    parts = addrToIPPort(addr)
  } catch (e) {
    return false
  }
  var host = parts[0]
  var port = parts[1]
  return port &gt; 0 &amp;&amp; port &lt; 65535 &amp;&amp;
    !(host === '127.0.0.1' &amp;&amp; port === this.client.torrentPort)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Torrent.prototype._addPeer = function (peer) {
var self = this
if (self.destroyed) {
  if (typeof peer !== 'string') peer.destroy()
  return null
}
if (typeof peer === 'string' &amp;&amp; !self.<span class="apidocCodeKeywordSpan">_validAddr</span>(peer)) {
  self._debug('ignoring peer: invalid %s', peer)
  return null
}

var id = (peer &amp;&amp; peer.id) || peer
if (self._peers[id]) {
  self._debug('ignoring peer: duplicate (%s)', id)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype._verifyPieces" id="apidoc.element.webtorrent.torrent.prototype._verifyPieces">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>_verifyPieces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_verifyPieces = function () {
  var self = this
  parallelLimit(self.pieces.map(function (_, index) {
    return function (cb) {
      if (self.destroyed) return cb(new Error('torrent is destroyed'))

      self.store.get(index, function (err, buf) {
        if (self.destroyed) return cb(new Error('torrent is destroyed'))

        if (err) return process.nextTick(cb, null) // ignore error
        sha1(buf, function (hash) {
          if (self.destroyed) return cb(new Error('torrent is destroyed'))

          if (hash === self._hashes[index]) {
            if (!self.pieces[index]) return
            self._debug('piece verified %s', index)
            self._markVerified(index)
          } else {
            self._debug('piece invalid %s', index)
          }
          cb(null)
        })
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    if (err) return self._destroy(err)
    self._debug('done verifying')
    self._onStore()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (unchanged) {
      for (var index = 0; index &lt; self.pieces.length; index++) {
        self._markVerified(index)
      }
      self._onStore()
    } else {
      self.<span class="apidocCodeKeywordSpan">_verifyPieces</span>()
    }
  })
} else {
  self._verifyPieces()
}

self.emit('metadata')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.addPeer" id="apidoc.element.webtorrent.torrent.prototype.addPeer">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>addPeer
        <span class="apidocSignatureSpan">(peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPeer = function (peer) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.infoHash) throw new Error('addPeer() must not be called before the `infoHash` event')

  if (self.client.blocked) {
    var host
    if (typeof peer === 'string') {
      var parts
      try {
        parts = addrToIPPort(peer)
      } catch (e) {
        self._debug('ignoring peer: invalid %s', peer)
        self.emit('invalidPeer', peer)
        return false
      }
      host = parts[0]
    } else if (typeof peer.remoteAddress === 'string') {
      host = peer.remoteAddress
    }

    if (host &amp;&amp; self.client.blocked.contains(host)) {
      self._debug('ignoring peer: blocked %s', peer)
      if (typeof peer !== 'string') peer.destroy()
      self.emit('blockedPeer', peer)
      return false
    }
  }

  var wasAdded = !!self._addPeer(peer)
  if (wasAdded) {
    self.emit('peer', peer)
  } else {
    self.emit('invalidPeer', peer)
  }
  return wasAdded
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function onError (err) {
  self._destroy(err)
}

function onPeer (peer) {
  // Don't create new outgoing TCP connections when torrent is done
  if (typeof peer === 'string' &amp;&amp; self.done) return
  self.<span class="apidocCodeKeywordSpan">addPeer</span>(peer)
}

function onTrackerAnnounce () {
  self.emit('trackerAnnounce')
  if (self.numPeers === 0) self.emit('noPeers', 'tracker')
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.addWebSeed" id="apidoc.element.webtorrent.torrent.prototype.addWebSeed">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>addWebSeed
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addWebSeed = function (url) {
  if (this.destroyed) throw new Error('torrent is destroyed')

  if (!/^https?:\/\/.+/.test(url)) {
    this.emit('warning', new Error('ignoring invalid web seed: ' + url))
    this.emit('invalidPeer', url)
    return
  }

  if (this._peers[url]) {
    this.emit('warning', new Error('ignoring duplicate web seed: ' + url))
    this.emit('invalidPeer', url)
    return
  }

  this._debug('add web seed %s', url)

  var newPeer = Peer.createWebSeedPeer(url, this)
  this._peers[newPeer.id] = newPeer
  this._peersLength += 1

  this.emit('peer', url)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

self._processParsedTorrent(parsedTorrent)
self.metadata = self.torrentFile

// add web seed urls (BEP19)
if (self.client.enableWebSeeds) {
  self.urlList.forEach(function (url) {
    self.<span class="apidocCodeKeywordSpan">addWebSeed</span>(url)
  })
}

// start off selecting the entire torrent with low priority
if (self.pieces.length !== 0) {
  self.select(0, self.pieces.length - 1, false)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.createServer" id="apidoc.element.webtorrent.torrent.prototype.createServer">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>createServer
        <span class="apidocSignatureSpan">(requestListener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer = function (requestListener) {
  if (typeof Server !== 'function') throw new Error('node.js-only method')
  if (this.destroyed) throw new Error('torrent is destroyed')
  var server = new Server(this, requestListener)
  this._servers.push(server)
  return server
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var http = require('http')
var mime = require('mime')
var pump = require('pump')
var rangeParser = require('range-parser')
var url = require('url')

function Server (torrent, requestListener) {
var server = http.<span class="apidocCodeKeywordSpan">createServer</span>(requestListener)

var sockets = []
var pendingReady = []
var closed = false

server.on('connection', onConnection)
server.on('request', onRequest)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.critical" id="apidoc.element.webtorrent.torrent.prototype.critical">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>critical
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">critical = function (start, end) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  self._debug('critical %s-%s', start, end)

  for (var i = start; i &lt;= end; ++i) {
    self._critical[i] = true
  }

  self._updateSelections()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

FileStream.prototype._notify = function () {
var self = this

if (!self._reading || self._missing === 0) return
if (!self._torrent.bitfield.get(self._piece)) {
  return self._torrent.<span class="apidocCodeKeywordSpan">critical</span>(self._piece, self._piece + self._criticalLength)
}

if (self._notifying) return
self._notifying = true

var p = self._piece
self._torrent.store.get(p, function (err, buffer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.deselect" id="apidoc.element.webtorrent.torrent.prototype.deselect">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>deselect
        <span class="apidocSignatureSpan">(start, end, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deselect = function (start, end, priority) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  priority = Number(priority) || 0
  self._debug('deselect %s-%s (priority %s)', start, end, priority)

  for (var i = 0; i &lt; self._selections.length; ++i) {
    var s = self._selections[i]
    if (s.from === start &amp;&amp; s.to === end &amp;&amp; s.priority === priority) {
      self._selections.splice(i, 1)
      break
    }
  }

  self._updateSelections()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

FileStream.prototype._destroy = function (err, onclose) {
  if (this.destroyed) return
  this.destroyed = true

  if (!this._torrent.destroyed) {
    this._torrent.<span class="apidocCodeKeywordSpan">deselect</span>(this._startPiece, this._endPiece, true)
  }

  if (err) this.emit('error', err)
  this.emit('close')
  if (onclose) onclose()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.destroy" id="apidoc.element.webtorrent.torrent.prototype.destroy">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>destroy
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (cb) {
  var self = this
  self._destroy(null, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
var torrent = this.get(torrentId)
if (!torrent) return
this.torrents.splice(this.torrents.indexOf(torrent), 1)
torrent.<span class="apidocCodeKeywordSpan">destroy</span>(cb)
}

WebTorrent.prototype.address = function () {
if (!this.listening) return null
return this._tcpPool
  ? this._tcpPool.server.address()
  : { address: '0.0.0.0', family: 'IPv4', port: 0 }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.getFileModtimes" id="apidoc.element.webtorrent.torrent.prototype.getFileModtimes">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>getFileModtimes
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFileModtimes = function (cb) {
  var self = this
  var ret = []
  parallelLimit(self.files.map(function (file, index) {
    return function (cb) {
      fs.stat(path.join(self.path, file.path), function (err, stat) {
        if (err &amp;&amp; err.code !== 'ENOENT') return cb(err)
        ret[index] = stat &amp;&amp; stat.mtime.getTime()
        cb(null)
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    self._debug('done getting file modtimes')
    cb(err, ret)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    self._onWireWithMetadata(wire)
  })

  self._debug('verifying existing torrent data')
  if (self._fileModtimes &amp;&amp; self._store === FSChunkStore) {
    // don't verify if the files haven't been modified since we last checked
    self.<span class="apidocCodeKeywordSpan">getFileModtimes</span>(function (err, fileModtimes) {
if (err) return self._destroy(err)

var unchanged = self.files.map(function (_, index) {
  return fileModtimes[index] === self._fileModtimes[index]
}).every(function (x) {
  return x
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.load" id="apidoc.element.webtorrent.torrent.prototype.load">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>load
        <span class="apidocSignatureSpan">(streams, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (streams, cb) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.ready) return self.once('ready', function () { self.load(streams, cb) })

  if (!Array.isArray(streams)) streams = [ streams ]
  if (!cb) cb = noop

  var readable = new MultiStream(streams)
  var writable = new ChunkStoreWriteStream(self.store, self.pieceLength)

  pump(readable, writable, function (err) {
    if (err) return cb(err)
    self.pieces.forEach(function (piece, index) {
      self.pieces[index] = null
      self._reservations[index] = null
      self.bitfield.set(index, true)
    })
    self._checkDone()
    cb(null)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    })
  })
})

function onTorrent (torrent) {
  var tasks = [
    function (cb) {
      torrent.<span class="apidocCodeKeywordSpan">load</span>(streams, cb)
    }
  ]
  if (self.dht) {
    tasks.push(function (cb) {
      torrent.once('dhtAnnounce', cb)
    })
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.pause" id="apidoc.element.webtorrent.torrent.prototype.pause">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  if (this.destroyed) return
  this._debug('pause')
  this.paused = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.removePeer" id="apidoc.element.webtorrent.torrent.prototype.removePeer">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>removePeer
        <span class="apidocSignatureSpan">(peer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePeer = function (peer) {
  var self = this
  var id = (peer &amp;&amp; peer.id) || peer
  peer = self._peers[id]

  if (!peer) return

  this._debug('removePeer %s', id)

  delete self._peers[id]
  self._peersLength -= 1

  peer.destroy()

  // If torrent swarm was at capacity before, try to open a new connection now
  self._drain()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    arrayRemove(swarm.wires, swarm.wires.indexOf(wire))
  }
  if (conn) {
    conn.on('error', noop)
    conn.destroy()
  }
  if (wire) wire.destroy()
  if (swarm) swarm.<span class="apidocCodeKeywordSpan">removePeer</span>(self.id)
}

function noop () {}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.resume" id="apidoc.element.webtorrent.torrent.prototype.resume">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  if (this.destroyed) return
  this._debug('resume')
  this.paused = false
  this._drain()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.torrent.prototype.select" id="apidoc.element.webtorrent.torrent.prototype.select">
        function <span class="apidocSignatureSpan">webtorrent.torrent.prototype.</span>select
        <span class="apidocSignatureSpan">(start, end, priority, notify)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (start, end, priority, notify) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  if (start &lt; 0 || end &lt; start || self.pieces.length &lt;= end) {
    throw new Error('invalid selection ', start, ':', end)
  }
  priority = Number(priority) || 0

  self._debug('select %s-%s (priority %s)', start, end, priority)

  self._selections.push({
    from: start,
    to: end,
    offset: 0,
    priority: priority,
    notify: notify || noop
  })

  self._selections.sort(function (a, b) {
    return b.priority - a.priority
  })

  self._updateSelections()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return downloaded
  }
})

File.prototype.select = function (priority) {
  if (this.length === 0) return
  this._torrent.<span class="apidocCodeKeywordSpan">select</span>(this._startPiece, this._endPiece, priority)
}

File.prototype.deselect = function () {
  if (this.length === 0) return
  this._torrent.deselect(this._startPiece, this._endPiece, false)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.webconn" id="apidoc.module.webtorrent.webconn">module webtorrent.webconn</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.webconn.webconn" id="apidoc.element.webtorrent.webconn.webconn">
        function <span class="apidocSignatureSpan">webtorrent.</span>webconn
        <span class="apidocSignatureSpan">(url, torrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebConn(url, torrent) {
  Wire.call(this)

  this.url = url
  this.webPeerId = sha1.sync(url)
  this._torrent = torrent

  this._init()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.webconn.super_" id="apidoc.element.webtorrent.webconn.super_">
        function <span class="apidocSignatureSpan">webtorrent.webconn.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Wire() {
  if (!(this instanceof Wire)) return new Wire()
  stream.Duplex.call(this)

  this._debugId = randombytes(4).toString('hex')
  this._debug('new wire')

  this.peerId = null // remote peer id (hex string)
  this.peerIdBuffer = null // remote peer id (buffer)
  this.type = null // connection type ('webrtc', 'tcpIncoming', 'tcpOutgoing', 'webSeed')

  this.amChoking = true // are we choking the peer?
  this.amInterested = false // are we interested in the peer?

  this.peerChoking = true // is the peer choking us?
  this.peerInterested = false // is the peer interested in us?

  // The largest torrent that I know of (the Geocities archive) is ~641 GB and has
  // ~41,000 pieces. Therefore, cap bitfield to 10x larger (400,000 bits) to support all
  // possible torrents but prevent malicious peers from growing bitfield to fill memory.
  this.peerPieces = new BitField(0, { grow: BITFIELD_GROW })

  this.peerExtensions = {}

  this.requests = [] // outgoing
  this.peerRequests = [] // incoming

  this.extendedMapping = {} // number -&gt; string, ex: 1 -&gt; 'ut_metadata'
  this.peerExtendedMapping = {} // string -&gt; number, ex: 9 -&gt; 'ut_metadata'

  // The extended handshake to send, minus the "m" field, which gets automatically
  // filled from `this.extendedMapping`
  this.extendedHandshake = {}

  this.peerExtendedHandshake = {} // remote peer's extended handshake

  this._ext = {}  // string -&gt; function, ex 'ut_metadata' -&gt; ut_metadata()
  this._nextExt = 1

  this.uploaded = 0
  this.downloaded = 0
  this.uploadSpeed = speedometer()
  this.downloadSpeed = speedometer()

  this._keepAliveInterval = null
  this._timeout = null
  this._timeoutMs = 0

  this.destroyed = false // was the wire ended by calling `destroy`?
  this._finished = false

  this._parserSize = 0 // number of needed bytes to parse next message from remote peer
  this._parser = null // function to call once `this._parserSize` bytes are available

  this._buffer = [] // incomplete message data
  this._bufferSize = 0 // cached total length of buffers in `this._buffer`

  this.on('finish', this._onFinish)

  this._parseHandshake()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.webtorrent.webconn.prototype" id="apidoc.module.webtorrent.webconn.prototype">module webtorrent.webconn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.webtorrent.webconn.prototype._init" id="apidoc.element.webtorrent.webconn.prototype._init">
        function <span class="apidocSignatureSpan">webtorrent.webconn.prototype.</span>_init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_init = function () {
  var self = this
  self.setKeepAlive(true)

  self.once('handshake', function (infoHash, peerId) {
    if (self.destroyed) return
    self.handshake(infoHash, self.webPeerId)
    var numPieces = self._torrent.pieces.length
    var bitfield = new BitField(numPieces)
    for (var i = 0; i &lt;= numPieces; i++) {
      bitfield.set(i, true)
    }
    self.bitfield(bitfield)
  })

  self.once('interested', function () {
    debug('interested')
    self.unchoke()
  })

  self.on('uninterested', function () { debug('uninterested') })
  self.on('choke', function () { debug('choke') })
  self.on('unchoke', function () { debug('unchoke') })
  self.on('bitfield', function () { debug('bitfield') })

  self.on('request', function (pieceIndex, offset, length, callback) {
    debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length)
    self.httpRequest(pieceIndex, offset, length, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function WebConn (url, torrent) {
Wire.call(this)

this.url = url
this.webPeerId = sha1.sync(url)
this._torrent = torrent

this.<span class="apidocCodeKeywordSpan">_init</span>()
}

WebConn.prototype._init = function () {
var self = this
self.setKeepAlive(true)

self.once('handshake', function (infoHash, peerId) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.webconn.prototype.destroy" id="apidoc.element.webtorrent.webconn.prototype.destroy">
        function <span class="apidocSignatureSpan">webtorrent.webconn.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  Wire.prototype.destroy.call(this)
  this._torrent = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
var torrent = this.get(torrentId)
if (!torrent) return
this.torrents.splice(this.torrents.indexOf(torrent), 1)
torrent.<span class="apidocCodeKeywordSpan">destroy</span>(cb)
}

WebTorrent.prototype.address = function () {
if (!this.listening) return null
return this._tcpPool
  ? this._tcpPool.server.address()
  : { address: '0.0.0.0', family: 'IPv4', port: 0 }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.webtorrent.webconn.prototype.httpRequest" id="apidoc.element.webtorrent.webconn.prototype.httpRequest">
        function <span class="apidocSignatureSpan">webtorrent.webconn.prototype.</span>httpRequest
        <span class="apidocSignatureSpan">(pieceIndex, offset, length, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">httpRequest = function (pieceIndex, offset, length, cb) {
  var self = this
  var pieceOffset = pieceIndex * self._torrent.pieceLength
  var rangeStart = pieceOffset + offset<span class="apidocCodeCommentSpan"> /* offset within whole torrent */
</span>  var rangeEnd = rangeStart + length - 1

  // Web seed URL format:
  // For single-file torrents, make HTTP range requests directly to the web seed URL
  // For multi-file torrents, add the torrent folder and file name to the URL
  var files = self._torrent.files
  var requests
  if (files.length &lt;= 1) {
    requests = [{
      url: self.url,
      start: rangeStart,
      end: rangeEnd
    }]
  } else {
    var requestedFiles = files.filter(function (file) {
      return file.offset &lt;= rangeEnd &amp;&amp; (file.offset + file.length) &gt; rangeStart
    })
    if (requestedFiles.length &lt; 1) {
      return cb(new Error('Could not find file corresponnding to web seed range request'))
    }

    requests = requestedFiles.map(function (requestedFile) {
      var fileEnd = requestedFile.offset + requestedFile.length - 1
      var url = self.url +
        (self.url[self.url.length - 1] === '/' ? '' : '/') +
        requestedFile.path
      return {
        url: url,
        fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
        start: Math.max(rangeStart - requestedFile.offset, 0),
        end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
      }
    })
  }

  // Now make all the HTTP requests we need in order to load this piece
  // Usually that's one requests, but sometimes it will be multiple
  // Send requests in parallel and wait for them all to come back
  var numRequestsSucceeded = 0
  var hasError = false

  var ret
  if (requests.length &gt; 1) {
    ret = Buffer.alloc(length)
  }

  requests.forEach(function (request) {
    var url = request.url
    var start = request.start
    var end = request.end
    debug(
      'Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d',
      url, pieceIndex, offset, length, start, end
    )
    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)',
        range: 'bytes=' + start + '-' + end
      }
    }
    function onResponse (res, data) {
      if (res.statusCode &lt; 200 || res.statusCode &gt;= 300) {
        hasError = true
        return cb(new Error('Unexpected HTTP status code ' + res.statusCode))
      }
      debug('Got data of length %d', data.length)

      if (requests.length === 1) {
        // Common case: fetch piece in a single HTTP request, return directly
        cb(null, data)
      } else {
        // Rare case: reconstruct multiple HTTP requests across 2+ files into one
        // piece buffer
        data.copy(ret, request.fileOffsetInRange)
        if (++numRequestsSucceeded === requests.length) {
          cb(null, ret)
        }
      }
    }
    get.concat(opts, function (err, res, data) {
      if (hasError) return
      if (err) {
        // Browsers allow HTTP redirects for simple cross-origin
        // requests but not for requests that require preflight.
        // Use a simple request to unravel any redirects and get the
        // final URL.  Retry the original request with the new URL if
        // it's different.
        //
        // This test is imperfect but it's simple and good for common
        // cases.  It catches all cross-origin cases but matches a few
        // same-origin cases too.
        if (typeof window === 'undefined' || url.startsWith(window.location.origin + '/')) {
          hasError = true
          return cb(err)
        }

        return get.head(url, function (errHead, res) {
          if (hasError) return
          if (errHead) {
            hasError = true
            return cb(errHead)
          }
          if (res.statusCode &lt; 200 || res.statusCode &gt;= 300) {
            hasError = true
            return cb(new Error('Unexpected HTTP status code ' + res.statusCode))
          }
          if (res.url === url) {
            hasError = true
            return cb(err)
          }

          opts.url = res.url ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.on('uninterested', function () { debug('uninterested') })
self.on('choke', function () { debug('choke') })
self.on('unchoke', function () { debug('unchoke') })
self.on('bitfield', function () { debug('bitfield') })

self.on('request', function (pieceIndex, offset, length, callback) {
  debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length)
  self.<span class="apidocCodeKeywordSpan">httpRequest</span>(pieceIndex, offset, length, callback)
})
}

WebConn.prototype.httpRequest = function (pieceIndex, offset, length, cb) {
var self = this
var pieceOffset = pieceIndex * self._torrent.pieceLength
var rangeStart = pieceOffset + offset /* offset within whole torrent */
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>